package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.PreUpdateEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.DoubleSliderValue;
import cc.unknown.module.setting.impl.SliderValue;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.MathHelper;

@Register(name = "TickBase", category = Category.Exploit)
public class TickBase extends Module {

	private DoubleSliderValue range = new DoubleSliderValue("Range", 5, 6, 0, 10, 1);
	private SliderValue delay = new SliderValue("Delay", 1, 0, 1, 0.1);
	private SliderValue duration = new SliderValue("Duration", 0.1, 0, 1, 0.1);
	private SliderValue timer = new SliderValue("Timer", 5, 1, 20, 1);
	private SliderValue maxTicks = new SliderValue("Max Ticks per Use", 20, 1, 100, 1);
	private SliderValue storeTicks = new SliderValue("Store Ticks", 40, 10, 100, 1);

	public TickBase() {
		this.registerSetting(range, delay, duration, timer, maxTicks, storeTicks);
	}

	private float violation = 0;

	private int delayTicks = 0, useTicks = 0;

	private Entity findTarget() {
		List<Entity> e = new ArrayList<>();
		float f = range.getInputMaxToFloat();
		for (final Entity o : mc.theWorld.getLoadedEntityList()) {
			if (!(o instanceof EntityLivingBase))
				continue;
			EntityLivingBase livingBase = (EntityLivingBase) o;
			if (o instanceof EntityPlayer) {
				if (livingBase.isEntityAlive() && livingBase != mc.thePlayer
						&& mc.thePlayer.getDistanceSqToEntity(o) <= f) {
					e.add(o);
				}
			}
		}
		if (e.size() == 0)
			return null;
		e.sort(Comparator.comparingInt(a -> (int) (a.getDistanceSqToEntity(mc.thePlayer) * 100)));
		return e.get(0);
	}

	@Override
	public void onEnable() {
		super.onEnable();
	}

	private void onUpdate() {

		Entity target;
		target = findTarget();

		if (target == null) {
			reset();
			return;
		}
		double dist = range.getInputMaxToFloat();
		double minDist = range.getInputMinToFloat();
		if (mc.thePlayer.getDistanceSqToEntity(target) > dist || mc.thePlayer.getDistanceSqToEntity(target) < minDist) {
			reset();
			return;
		}

		delayTicks++;
		if (delayTicks > (int) (delay.getInputToFloat() * 30)) {
			mc.timer.timerSpeed = timer.getInputToFloat();
			useTicks++;
			if (violation < storeTicks.getInputToFloat() / timer.getInputToFloat()) {
				violation += 1;
				violation = MathHelper.clamp_float(violation, 0.0f, storeTicks.getInputToFloat() / timer.getInputToFloat());
			} else {
				reset();
				return;
			}

			if (useTicks > maxTicks.getInputToInt()) {
				reset();
			}
		} else {
			mc.timer.timerSpeed = 1f;
		}
	}

	@EventLink
	public void onPre(PreUpdateEvent e) {
		onUpdate();
	}

	public void reset() {
		mc.timer.timerSpeed = 1f;
		delayTicks = 0;
		useTicks = 0;
	}

	@Override
	public void onDisable() {
		mc.timer.timerSpeed = 1.0f;
		super.onDisable();
	}

}
