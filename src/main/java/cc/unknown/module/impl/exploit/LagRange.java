package cc.unknown.module.impl.exploit;

import java.util.concurrent.CopyOnWriteArrayList;

import cc.unknown.Haru;
import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.MotionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.impl.combat.AimAssist;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.player.CombatUtil;
import net.minecraft.entity.Entity;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S06PacketUpdateHealth;
import net.minecraft.network.play.server.S13PacketDestroyEntities;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.util.AxisAlignedBB;

@Register(name = "LagRange", category = Category.Exploit)
public class LagRange extends Module {

	private SliderValue leaveRange = new SliderValue("Leave Range", 6, 0, 10, 1);
	private SliderValue minRange = new SliderValue("Min Range", 0, 0, 6, 1);
	private SliderValue range = new SliderValue("Start Range", 3, 0, 6, 1);
	private SliderValue duration = new SliderValue("Max Duration", 0.1, 0, 3, 1);

	private int durationTicks;
	private CopyOnWriteArrayList<Packet<?>> serverPackets = new CopyOnWriteArrayList<>();
	private CopyOnWriteArrayList<Entity> storeEntities = new CopyOnWriteArrayList<>();

	private Entity targets;
	private boolean freezing;

	public LagRange() {
		this.registerSetting(leaveRange, minRange, range, duration);
	}

	private void clear() {
		freezing = false;
		if (mc.getNetHandler() != null)
			serverPackets.forEach((e) -> {
				try {
					((Packet<INetHandler>) e).processPacket(mc.getNetHandler());
				} catch (Exception ignored) {
				}
			});
		storeEntities.forEach((entity) -> {
			if (entity == null || !entity.isEntityAlive())
				return;
			double x = entity.serverPosX;
			double y = entity.serverPosY;
			double z = entity.serverPosZ;
			entity.setPosition(x, y, z);
		});
		targets = null;
		storeEntities.clear();
		serverPackets.clear();
		durationTicks = 0;
	}

	@Override
	public void onEnable() {
		clear();
	}

	@Override
	public void onDisable() {
		clear();
	}

	@EventLink
	public void onPost(MotionEvent e) {
		if (e.isPost()) {
			AimAssist aimAssist = (AimAssist) Haru.instance.getModuleManager().getModule(AimAssist.class);

			if (mc.theWorld == null || mc.thePlayer == null)
				return;

			int countInRange = 0;
			for (Entity entity : mc.theWorld.getLoadedEntityList()) {
				AxisAlignedBB afterBB = entity.getEntityBoundingBox();
				double afterRange = CombatUtil.instance.getNearestPointBB(afterBB);
				if (afterRange <= aimAssist.enemyDetectionRange.getInputToFloat())
					countInRange++;

			}

			if (countInRange > 1) {
				clear();
				return;
			}

			if (freezing) {
				int calcDuration = (int) (duration.getInputToFloat() * 10);
				durationTicks++;
				if (durationTicks > calcDuration || aimAssist.getEnemy() == null) {
					clear();
					return;
				}
			}

			if (!storeEntities.isEmpty()) {
				for (Entity entity : storeEntities) {
					double x = entity.serverPosX;
					double y = entity.serverPosY;
					double z = entity.serverPosZ;
					AxisAlignedBB entityBB = new AxisAlignedBB(x - 0.4F, y, z - 0.4F, x + 0.4F, y + 1.7F, z + 0.4F);
					double range = CombatUtil.instance.getNearestPointBB(entityBB);
					if (range <= minRange.getInputToFloat() || range >= leaveRange.getInputToFloat()) {
						clear();
						break;
					}
				}
			}

			if (aimAssist.getEnemy() != null) {
				if (targets != null && aimAssist.getEnemy() != targets) {
					clear();
				}
				AxisAlignedBB afterBB = aimAssist.getEnemy().getEntityBoundingBox();
				double afterRange = CombatUtil.instance.getNearestPointBB(afterBB);

				if (afterRange >= minRange.getInputToFloat() && afterRange <= range.getInputToFloat()) {
					if (!freezing) {
						durationTicks = 0;
						freezing = true;
					}
					targets = aimAssist.getEnemy();
					return;
				}
			}
		}
	}

	@EventLink
	public void onPacketEvent(PacketEvent e) {
		if (mc.theWorld == null || mc.thePlayer == null)
			return;
		if (e.isSend()) {
			if (freezing && e.getPacket() instanceof C02PacketUseEntity) {
				if (((C02PacketUseEntity) e.getPacket()).getEntityFromWorld(mc.theWorld) != targets) {
					clear();
				}
			}
			return;
		}

		if (e.isReceive()) {
			if (freezing && !e.isCancelled()
					&& !(e.getPacket() instanceof S06PacketUpdateHealth
							|| e.getPacket() instanceof S19PacketEntityStatus
							|| e.getPacket() instanceof S13PacketDestroyEntities)) {
				serverPackets.add(e.getPacket());
				e.setCancelled(true);
			}
		}

	}
}
