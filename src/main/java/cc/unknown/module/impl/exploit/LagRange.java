package cc.unknown.module.impl.exploit;

import java.util.LinkedList;
import java.util.concurrent.CopyOnWriteArrayList;

import cc.unknown.Haru;
import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.PostMotionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.network.PacketEvent.Type;
import cc.unknown.event.impl.world.WorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.impl.combat.AimAssist;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.player.CombatUtil;
import net.minecraft.entity.Entity;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S06PacketUpdateHealth;
import net.minecraft.network.play.server.S13PacketDestroyEntities;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;

@Register(name = "LagRange", category = Category.Exploit)
public class LagRange extends Module {

	private SliderValue leaveRange = new SliderValue("Leave Range", 6, 0, 10, 1);
	private SliderValue minRange = new SliderValue("Min Range", 0, 0, 6, 1);
	private SliderValue range = new SliderValue("Start Range", 3, 0, 6, 1);
	private SliderValue duration = new SliderValue("Max Duration", 0.1, 0, 3, 1);

	private int durationTicks = 0;
	private CopyOnWriteArrayList<Packet<?>> serverPackets = new CopyOnWriteArrayList<>();
	private CopyOnWriteArrayList<Entity> storeEntities = new CopyOnWriteArrayList<>();
	private LinkedList<PacketEvent> packets = new LinkedList<>();

	private Entity targets = null;
	private boolean freezing = false;
	
	public LagRange() {
		this.registerSetting(leaveRange, minRange, range, duration);
	}

	private void clear() {
		freezing = false;
		if (mc.getNetHandler() != null)
			serverPackets.forEach((e) -> {
				PacketEvent ev = packets.pollFirst();
				try {
					if (!ev.isCancelled())
						((Packet<INetHandler>) e).processPacket(mc.getNetHandler());
				} catch (Exception ignored) {
				}
			});
		storeEntities.forEach((entity) -> {
			if (entity == null || !entity.isEntityAlive())
				return;
			double x = entity.serverPosX;
			double y = entity.serverPosY;
			double z = entity.serverPosZ;
			entity.setPosition(x, y, z);
		});
		targets = null;
		storeEntities.clear();
		serverPackets.clear();
		durationTicks = 0;
	}

	@EventLink
	public void onWorldEvent(WorldEvent e) {
		serverPackets.clear();
		storeEntities.clear();
		clear();
	}

	@Override
	public void onEnable() {
		clear();
		super.onEnable();
	}

	@Override
	public void onDisable() {
		clear();
		super.onDisable();
	}

	@EventLink
	public void onPost(PostMotionEvent e) {
		AimAssist aimAssist = (AimAssist) Haru.instance.getModuleManager().getModule(AimAssist.class);
		
		if (mc.theWorld == null || mc.thePlayer == null)
			return;

		int countInRange = 0;
		for (Entity entity : mc.theWorld.getLoadedEntityList()) {
			AxisAlignedBB afterBB = entity.getEntityBoundingBox();
			double afterRange = CombatUtil.instance.getNearestPointBB(afterBB);
			if (afterRange <= aimAssist.enemyDetectionRange.getInputToFloat())
				countInRange++;

		}
		
		if (countInRange > 1) {
			clear();
			return;
		}

		if (freezing) {
			int calcDuration = (int) (duration.getInputToFloat() * 10);
			durationTicks++;
			if (durationTicks > calcDuration || aimAssist.getEnemy() == null) {
				clear();
				return;
			}
		}

		if (!storeEntities.isEmpty()) {
			for (Entity entity : storeEntities) {
				double x = entity.serverPosX;
				double y = entity.serverPosY;
				double z = entity.serverPosZ;
				AxisAlignedBB entityBB = new AxisAlignedBB(x - 0.4F, y, z - 0.4F, x + 0.4F, y + 1.7F, z + 0.4F);
				double range = CombatUtil.instance.getNearestPointBB(entityBB);
				if (range <= minRange.getInputToFloat() || range >= leaveRange.getInputToFloat()) {
					clear();
					break;
				}
			}
		}

		if (aimAssist.getEnemy() != null) {
			if (targets != null && aimAssist.getEnemy() != targets) {
				clear();
			}
			AxisAlignedBB afterBB = aimAssist.getEnemy().getEntityBoundingBox();
			double afterRange = CombatUtil.instance.getNearestPointBB(afterBB);

			if (afterRange >= minRange.getInputToFloat() && afterRange <= range.getInputToFloat()) {
				if (!freezing) {
					durationTicks = 0;
					freezing = true;
				}
				targets = aimAssist.getEnemy();
				return;
			} else {
				targets = aimAssist.getEnemy();
				durationTicks = 0;
			}
		}
	}

	@EventLink
	public void onPacketEvent(PacketEvent e) {
		if (mc.theWorld == null || mc.thePlayer == null)
			return;
		if (e.getType() == Type.SEND) {
			if (freezing && e.getPacket() instanceof C02PacketUseEntity) {
				if (((C02PacketUseEntity) e.getPacket()).getEntityFromWorld(mc.theWorld) != targets) {
					clear();
				}
			}
			return;
		}

		if (e.getType() == Type.RECEIVE) {
			if (e.getPacket() instanceof S14PacketEntity) {
				S14PacketEntity packet = (S14PacketEntity) e.getPacket();
				Entity entity = packet.getEntity(mc.theWorld);
				if (entity != null) {
					if (entity.ridingEntity == null) {
						Vec3 vec3 = new Vec3(packet.func_149062_c(), packet.func_149061_d(), packet.func_149064_e());
						entity.lastTickPosX = entity.prevPosX = entity.posX = vec3.xCoord;
						entity.lastTickPosY = entity.prevPosY = entity.posY = vec3.yCoord;
						entity.lastTickPosZ = entity.prevPosZ = entity.posZ = vec3.zCoord;
						entity.rotationYaw = packet.func_149066_f() * 360 / 256.0F;
						entity.rotationPitch = packet.func_149063_g() * 360 / 256.0F;
						entity.prevRotationYaw = entity.rotationYaw;
						entity.prevRotationPitch = entity.rotationPitch;
						entity.setEntityBoundingBox(entity.getEntityBoundingBox().offset(vec3.xCoord - entity.posX, vec3.yCoord - entity.posY, vec3.zCoord - entity.posZ));
						entity.setPositionAndRotation2(entity.posX, entity.posY, entity.posZ, entity.rotationYaw, entity.rotationPitch, 3, false);
						entity.onGround = packet.getOnGround();

						if (freezing) {
							if (!storeEntities.contains(entity))
								storeEntities.add(entity);
							packets.add(e);
							e.setCancelled(true);
							return;
						}
					}
					e.setCancelled(true);
				}
			}
		} else {
			if (freezing && !e.isCancelled()
					&& !(e.getPacket() instanceof S06PacketUpdateHealth
							|| e.getPacket() instanceof S19PacketEntityStatus
							|| e.getPacket() instanceof S13PacketDestroyEntities)) {
				packets.add(e);
				serverPackets.add(e.getPacket());
				e.setCancelled(true);
			}
		}

	}
}
