package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import javax.swing.Timer;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.UpdateEvent;
import cc.unknown.event.impl.move.UpdateEvent.Action;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.network.PacketEvent.Type;
import cc.unknown.event.impl.other.ShutdownEvent;
import cc.unknown.event.impl.other.StartGameEvent;
import cc.unknown.event.impl.other.WorldEvent;
import cc.unknown.event.impl.player.TickEvent;
import cc.unknown.event.impl.render.Render3DEvent;
import cc.unknown.mixin.interfaces.network.packets.IC02PacketUseEntity;
import cc.unknown.mixin.interfaces.network.packets.IS14PacketEntity;
import cc.unknown.module.Module;
import cc.unknown.module.impl.ModuleCategory;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.DoubleSliderValue;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.ui.clickgui.raven.impl.api.Theme;
import cc.unknown.utils.client.Cold;
import cc.unknown.utils.client.RenderUtil;
import cc.unknown.utils.helpers.MathHelper;
import cc.unknown.utils.network.PacketUtil;
import cc.unknown.utils.network.TimedPacket;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayServer;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.server.S02PacketChat;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.network.play.server.S13PacketDestroyEntities;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S18PacketEntityTeleport;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.network.play.server.S40PacketDisconnect;
import net.minecraft.util.Vec3;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent;

@SuppressWarnings("unchecked")
public class FakeLag extends Module {

	private ModeValue mode = new ModeValue("Mode", "Automatic", "Tick", "Latency", "Automatic");
	private DoubleSliderValue tick = new DoubleSliderValue("Ticks", 3, 4, 1, 20, 1);
	private BooleanValue legitimize = new BooleanValue("Cancel C03", true);
	private BooleanValue checkPackets = new BooleanValue("Only necessary packets", true);
	private BooleanValue onlyCombat = new BooleanValue("Only combat", true);
	private BooleanValue onWorld = new BooleanValue("Disable on world change", true);
	private SliderValue ping = new SliderValue("Additional ping", 12, 0, 95, 0.5);
	private SliderValue latency = new SliderValue("Latency delay", 200, 1, 1000, 1);

	private final List<Packet<INetHandlerPlayServer>> packets = new ArrayList<>();
	private Cold timer = new Cold();
	private static boolean b = true;

	//
	private Queue<TimedPacket> packetQueue = new ConcurrentLinkedQueue<>();
	private Vec3 vec3, lastVec3;
	private EntityPlayer target;
	private int attackTicks;

	public FakeLag() {
		super("FakeLag", ModuleCategory.Exploit);
		this.registerSetting(mode, tick, legitimize, onlyCombat, checkPackets, ping, latency, onWorld);
	}

	@Override
	public void onEnable() {
		super.onEnable();
		if (mc.thePlayer == null) {
			toggle();
			return;
		}

		if (mode.is("Latency")) {
			packetQueue.clear();
			vec3 = lastVec3 = null;
			target = null;
		}

		if (mode.is("Tick")) {
			synchronized (packets) {
				packets.clear();
			}
		}
	}

	@Override
	public void onDisable() {
		super.onDisable();
		if (mc.thePlayer == null)
			return;

		if (mode.is("Latency")) {
			if (mc.thePlayer != null && !packetQueue.isEmpty())
				packetQueue.forEach(timedPacket -> {
					PacketUtil.receivePacketNoEvent((Packet<INetHandler>) timedPacket.getPacket());
				});
			packetQueue.clear();
		}

		if (mode.is("Tick")) {
			List<Packet<INetHandlerPlayServer>> c;
			synchronized (packets) {
				c = new ArrayList<>(packets);
				packets.clear();
			}

			for (Packet<INetHandlerPlayServer> packet : c) {
				PacketUtil.sendPacketNoEvent(packet);
			}
		}
	}

	@EventLink
	public void onPreUpdate(UpdateEvent e) {
		if (e.getAction() == Action.PRE) {
			attackTicks++;

			if (attackTicks > 7 || vec3.distanceTo(mc.thePlayer.getPositionVector()) > 6) {
				target = null;
				vec3 = lastVec3 = null;
			}

			lastVec3 = vec3;

		}
	}

	@EventLink
	public void onPreTick(TickEvent.Pre e) {
		if (mode.is("Latency"))
			release();
	}

	@EventLink
	public void onUpdate(UpdateEvent e) {
		if (mode.is("Tick")) {
			List<Packet<INetHandlerPlayServer>> c;

			synchronized (packets) {
				c = new ArrayList<>(packets);
				if (mc.thePlayer.ticksExisted
						% MathHelper.randomInt(tick.getInputMinToInt(), tick.getInputMaxToInt()) == 0) {
					for (int i = 0; i < c.size(); i++) {
						PacketUtil.send(c.get(i));
					}
				}
			}
		}

		if (mode.is("Automatic")) {
			if (PlayerUtil.inGame() && mc.thePlayer.hurtTime == 0 && b) {
				b = false;
				timer.hasTimeElapsed(0, true);
				Timer timer = new Timer(ping.getInputToInt(), actionEvent -> b = true);
				timer.setRepeats(false);
				timer.start();
			}
		}
	}

	@EventLink
	public void onWorld(WorldEvent e) {
		if (onWorld.isToggled()) {
			this.disable();
		}
	}

	@EventLink
	public void onRender3D(Render3DEvent event) {
		if (target == null)
			return;
		RenderUtil.drawBackTrackBox(target, vec3, lastVec3, Theme.getMainColor(), false);
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (e.getType() == Type.RECEIVE) {

			if (mode.is("Latency")) {
				if (mc.thePlayer == null || mc.thePlayer.ticksExisted < 20) {
					packetQueue.clear();
					return;
				}

				if (target == null) {
					releaseAll();
					return;
				}
				if (e.isCancelled())
					return;

				if (e.getPacket() instanceof S19PacketEntityStatus || e.getPacket() instanceof S02PacketChat)
					return;
				if (e.getPacket() instanceof S08PacketPlayerPosLook || e.getPacket() instanceof S40PacketDisconnect) {
					releaseAll();
					target = null;
					vec3 = lastVec3 = null;
					return;
				} else if (e.getPacket() instanceof S13PacketDestroyEntities) {
					S13PacketDestroyEntities wrapper = (S13PacketDestroyEntities) e.getPacket();
					for (int id : wrapper.getEntityIDs()) {
						if (id == target.getEntityId()) {
							target = null;
							vec3 = lastVec3 = null;
							releaseAll();
							return;
						}
					}
				} else if (e.getPacket() instanceof S14PacketEntity) {
					S14PacketEntity wrapper = (S14PacketEntity) e.getPacket();
					if (((IS14PacketEntity) wrapper).getEntityId() == target.getEntityId()) {
						vec3 = vec3.addVector(wrapper.func_149062_c() / 32.0D, wrapper.func_149061_d() / 32.0D, wrapper.func_149064_e() / 32.0D);
					}
				} else if (e.getPacket() instanceof S18PacketEntityTeleport) {
					S18PacketEntityTeleport wrapper = (S18PacketEntityTeleport) e.getPacket();
					if (wrapper.getEntityId() == target.getEntityId()) {
						vec3 = new Vec3(wrapper.getX() / 32.0D, wrapper.getY() / 32.0D, wrapper.getZ() / 32.0D);
					}
				}

				packetQueue.add(new TimedPacket(e.getPacket()));
				e.setCancelled(true);
			}

			if (mode.is("Automatic")) {
				if (e.getPacket() instanceof S18PacketEntityTeleport) {
					S18PacketEntityTeleport wrapper = (S18PacketEntityTeleport) e.getPacket();

					if (target != null && wrapper.getEntityId() == target.getEntityId()) {
						vec3 = vec3.addVector(wrapper.getX() / 1.0D - 5.0D, wrapper.getYaw() / 1.0,
								wrapper.getPitch() / 1.0D - 15.0D);
					}
				}

				if (e.getPacket() instanceof S14PacketEntity) {
					S14PacketEntity wrapper = (S14PacketEntity) e.getPacket();
					if (target != null && ((IS14PacketEntity) wrapper).getEntityId() == target.getEntityId()) {

						double d0 = wrapper.func_149062_c() / 32.0;
						double d1 = wrapper.func_149061_d() / 32.0;
						double d2 = wrapper.func_149064_e() / 32.0;

						vec3 = vec3.addVector(d0, d1, d2);

					}
				}
			}
		}

		if (e.getType() == Type.SEND) {
			if (mode.is("Latency")) {
				if (e.getPacket() instanceof C02PacketUseEntity) {
					C02PacketUseEntity wrapper = (C02PacketUseEntity) e.getPacket();
					attackTicks = 0;

					Entity entity = wrapper.getEntityFromWorld(mc.theWorld);
					if (target != null && ((IC02PacketUseEntity) wrapper).getEntityId() == target.getEntityId())
						return;
					target = (EntityPlayer) entity;
					vec3 = lastVec3 = entity.getPositionVector();
				}
			}

			if (mode.is("Tick")) {
				synchronized (packets) {
					if (mode.is("Tick") && packets.contains(e.getPacket())) {
						packets.remove(e.getPacket());
						return;
					}

					if (mode.is("Tick")) {
						packets.add((Packet<INetHandlerPlayServer>) e.getPacket());
						e.setCancelled(true);
						return;
					}

					if (legitimize.isToggled()) {
						if (e.getPacket() instanceof C03PacketPlayer) {
							packets.add((Packet<INetHandlerPlayServer>) e.getPacket());
							e.setCancelled(true);
						}
					} else {
						if (!(e.getPacket() instanceof C00PacketKeepAlive)) {
							packets.add((Packet<INetHandlerPlayServer>) e.getPacket());
							e.setCancelled(true);
						}
					}
				}
			}

			if (e.getPacket() instanceof C02PacketUseEntity) {
				C02PacketUseEntity c02 = (C02PacketUseEntity) e.getPacket();
				if (onlyCombat.isToggled() && c02.getAction() != C02PacketUseEntity.Action.ATTACK)
					return;
			}
		}
	}

	@EventLink
	public void onStartGame(StartGameEvent e) {
		this.disable();
	}

	@EventLink
	public void onShutdown(ShutdownEvent e) {
		this.disable();
	}

	@SubscribeEvent
	public void onDisconnect(final FMLNetworkEvent.ClientDisconnectionFromServerEvent event) {
		this.disable();
		this.packets.clear();
	}

	private void release() {
		while (!packetQueue.isEmpty()) {
			if (packetQueue.peek().getCold().reached(latency.getInputToInt())) {
				Packet<?> packet = packetQueue.poll().getPacket();
				PacketUtil.receivePacketNoEvent((Packet<INetHandler>) packet);
			} else {
				break;
			}
		}

		if (packetQueue.isEmpty() && target != null) {
			vec3 = target.getPositionVector();
		}
	}

	private void releaseAll() {
		if (!packetQueue.isEmpty()) {
			packetQueue.forEach(timedPacket -> {
				PacketUtil.receivePacketNoEvent((Packet<INetHandler>) timedPacket.getPacket());
			});
			packetQueue.clear();
		}
	}
}
