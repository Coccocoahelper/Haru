package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import org.lwjgl.opengl.GL11;

import cc.unknown.Haru;
import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.PostUpdateEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.network.PacketEvent.Type;
import cc.unknown.event.impl.render.Render3DEvent;
import cc.unknown.event.impl.world.WorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.impl.combat.AimAssist;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.client.Cold;
import cc.unknown.utils.client.RenderUtil;
import cc.unknown.utils.network.PacketUtil;
import cc.unknown.utils.player.CombatUtil;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityArmorStand;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.ThreadQuickExitException;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement;
import net.minecraft.network.play.server.S01PacketJoinGame;
import net.minecraft.network.play.server.S03PacketTimeUpdate;
import net.minecraft.network.play.server.S07PacketRespawn;
import net.minecraft.network.play.server.S0CPacketSpawnPlayer;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S18PacketEntityTeleport;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;

@Register(name = "FakeLag", category = Category.Exploit)
public class FakeLag extends Module {

	private ModeValue mode = new ModeValue("Mode", "Dynamic", "Manual", "Automatic", "Dynamic");
	private BooleanValue esp = new BooleanValue("Render Server Pos", true);
	private SliderValue time = new SliderValue("Time", 200, 0, 2000, 1);
	private SliderValue size = new SliderValue("Delay Size", 100, 0, 1000, 1);

	private boolean needFreeze = false;
	private ArrayList<Packet<INetHandlerPlayClient>> storagePackets = new ArrayList<>();
	private ArrayList<Entity> storageEntities = new ArrayList<>();
	private Cold timer = new Cold(0);
	private Entity attacked = null;
	private Queue<Packet<?>> packets = new ConcurrentLinkedQueue<>();
	private LinkedHashMap<Integer, PosData> entityPosMap = new LinkedHashMap<>();

	public FakeLag() {
		this.registerSetting(mode, esp, time, size);
	}

	@Override
	public void onDisable() {
		releasePackets();
		clear();
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		try {
			Packet<?> p = e.getPacket();

			if (e.getType() == Type.RECEIVE) {

				if (mode.is("Dynamic")) {
					if (e.isCancelled())
						return;

					if (p instanceof S03PacketTimeUpdate)
						return;

					if (p instanceof S01PacketJoinGame || p instanceof S07PacketRespawn) {
						clear();
						return;
					}

					packets.add(e.getPacket());
					e.setCancelled(true);
					if (p instanceof S0CPacketSpawnPlayer) {
						S0CPacketSpawnPlayer spawn = (S0CPacketSpawnPlayer) p;
						if (entityPosMap.containsKey(spawn.getEntityID()))
							return;
						PosData pd = new PosData();
						pd.prevX = spawn.getX() / 32.0;
						pd.prevY = spawn.getY() / 32.0;
						pd.prevZ = spawn.getZ() / 32.0;
						entityPosMap.put(spawn.getEntityID(), pd);
					} else if (p instanceof S14PacketEntity) {
						S14PacketEntity entityPacket = (S14PacketEntity) p;
						PosData pd;
						int entityId = entityPacket.getEntity(mc.theWorld).getEntityId();
						if (!entityPosMap.containsKey(entityId)) {
							Entity entity = entityPacket.getEntity(mc.theWorld);
							if (entity == null || entity instanceof EntityArmorStand)
								return;
							pd = new PosData();
							pd.x = entity.serverPosX;
							pd.y = entity.serverPosY;
							pd.z = entity.serverPosZ;
							pd.width = entity.width / 2 + entity.getCollisionBorderSize();
							pd.height = entity.height + entity.getCollisionBorderSize();
							entityPosMap.put(entityId, pd);
						} else {
							pd = entityPosMap.get(entityId);
						}
						pd.motionX(entityPacket.func_149062_c());
						pd.motionY(entityPacket.func_149061_d());
						pd.motionZ(entityPacket.func_149064_e());
					} else if (p instanceof S18PacketEntityTeleport) {
						S18PacketEntityTeleport entityTeleport = (S18PacketEntityTeleport) p;
						PosData pd;
						int entityId = entityTeleport.getEntityId();
						if (!entityPosMap.containsKey(entityId)) {
							pd = new PosData();
							Entity entity = mc.theWorld.getEntityByID(entityId);
							if (entity != null) {
								pd.width = entity.width / 2 + entity.getCollisionBorderSize();
								pd.height = entity.height + entity.getCollisionBorderSize();
							}
							entityPosMap.put(entityId, pd);
						} else {
							pd = entityPosMap.get(entityId);
						}
						pd.x = entityTeleport.getX();
						pd.y = entityTeleport.getY();
						pd.z = entityTeleport.getZ();
					}
				}
			}

			if (e.getType() == Type.SEND) {
				if (mode.is("Dynamic")) {
					if (p instanceof C08PacketPlayerBlockPlacement) {
						C08PacketPlayerBlockPlacement place = (C08PacketPlayerBlockPlacement) p;
						if (place.getPlacedBlockDirection() == 255)
							return;
					}
				}
			}
		} catch (NullPointerException ex) {

		}

	}

	@EventLink
	public void onPost(PostUpdateEvent e) {
		if (mode.is("Dynamic")) {
			if (packets.isEmpty())
				return;
			clear(this.size.getInputToInt());
		} else {
			if (needFreeze) {
				if (!mode.is("Manual")) {
					if (timer.reached(time.getInputToLong())) {
						releasePackets();
						return;
					}
				}
				if (!storageEntities.isEmpty()) {
					boolean release = false;
					for (Entity entity : storageEntities) {
						double x = entity.serverPosX / 32.0;
						double y = entity.serverPosY / 32.0;
						double z = entity.serverPosZ / 32.0;
						AxisAlignedBB entityBB = new AxisAlignedBB(x - 0.4F, y - 0.1F, z - 0.4F, x + 0.4F, y + 1.9F,
								z + 0.4F);
						double range = CombatUtil.instance.getLookingTargetRange(mc.thePlayer, entityBB);
						if (range == Double.MAX_VALUE) {
							Vec3 eyes = mc.thePlayer.getPositionEyes(1F);
							range = CombatUtil.instance.getNearestPointBB(eyes, entityBB).distanceTo(eyes) + 0.075;
						}
						if (range <= 0.5) {
							release = true;
							break;
						}
						Entity entity1 = attacked;
						if (entity1 != entity)
							continue;
						if (!mode.is("Manual")) {
							if (timer.reached(time.getInputToLong())) {
								if (range >= 6) {
									release = true;
									break;
								}
							}
						}
					}
					if (!mode.is("Manual")) {
						if (release)
							releasePackets();
					}
				}
			}
		}
	}

	@EventLink
	public void onWorld(WorldEvent event) {
		if (mode.is("Dynamic")) {
			clear();
		} else {
			attacked = null;
			storageEntities.clear();
			if (event.getWorldClient() == null)
				storagePackets.clear();
		}
	}

	@EventLink
	public void onRender3D(Render3DEvent event) {
		if (!esp.isToggled())
			return;
		// pre draw
		GL11.glPushMatrix();
		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
		GL11.glEnable(GL11.GL_BLEND);
		GL11.glDisable(GL11.GL_TEXTURE_2D);
		GL11.glDisable(GL11.GL_DEPTH_TEST);
		GL11.glDepthMask(false);
		AimAssist c = (AimAssist) Haru.instance.getModuleManager().getModule(AimAssist.class);

		// drawing
		if (mode.is("Dynamic")) {
			for (PosData data : entityPosMap.values()) {
				if (c.getEnemy() != null) {
					double px = data.getPosX() - mc.getRenderManager().renderPosX;
					double py = data.getPosY() - mc.getRenderManager().renderPosY;
					double pz = data.getPosZ() - mc.getRenderManager().renderPosZ;
					AxisAlignedBB bb = new AxisAlignedBB(px - data.width, py, pz - data.width, px + data.width,
							py + data.height, pz + data.width);
					if (mc.thePlayer.hurtTime > 0)
						RenderUtil.glColor(255, 32, 32, 35);
					else
						RenderUtil.glColor(32, 255, 32, 35);
					RenderUtil.drawFilledBox(bb);
				}
			}
		} else {
			double renderPosX = mc.getRenderManager().renderPosX;
			double renderPosY = mc.getRenderManager().renderPosY;
			double renderPosZ = mc.getRenderManager().renderPosZ;
			for (Entity entity : storageEntities) {
				double x = entity.serverPosX / 32.0 - renderPosX;
				double y = entity.serverPosY / 32.0 - renderPosY;
				double z = entity.serverPosZ / 32.0 - renderPosZ;
				if (entity instanceof EntityPlayer) {
					if (mc.thePlayer.hurtTime > 0)
						RenderUtil.glColor(255, 32, 32, 35);
					else
						RenderUtil.glColor(32, 255, 32, 35);
					RenderUtil.drawFilledBox(new AxisAlignedBB(x - 0.4F, y, z - 0.4F, x + 0.4F, y + 1.9F, z + 0.4F));
				}
			}
		}

		// post draw
		GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
		GL11.glDepthMask(true);
		GL11.glDisable(GL11.GL_BLEND);
		GL11.glEnable(GL11.GL_TEXTURE_2D);
		GL11.glEnable(GL11.GL_DEPTH_TEST);
		GL11.glPopMatrix();
	}

	private void releasePackets() {
		if (mode.is("Dynamic"))
			return;
		attacked = null;
		if (storagePackets.isEmpty())
			return;
		while (!storagePackets.isEmpty()) {
			Packet<INetHandlerPlayClient> packet = storagePackets.remove(0);
			try {
				PacketUtil.sendPacketNoEvent(packet);
			} catch (ThreadQuickExitException ignored) {
			}
		}
		while (!storageEntities.isEmpty()) {
			Entity entity = storageEntities.remove(0);
			if (!entity.isDead) {
				double x = entity.serverPosX / 32.0;
				double y = entity.serverPosY / 32.0;
				double z = entity.serverPosZ / 32.0;
				entity.setPosition(x, y, z);
			}
		}
		needFreeze = false;
	}

	private void clear() {
		if (mode.is("Dynamic")) {
			entityPosMap.clear();
			clear(0);
		}
	}

	private void clear(int size) {
		if (mode.is("Dynamic")) {
			if (packets.isEmpty())
				return;
			INetHandlerPlayClient handler = mc.getNetHandler();
			while (packets.size() > size) {
				Packet<?> packet = packets.poll();
				if (packet == null)
					continue;
				try {
					((Packet<INetHandlerPlayClient>) packet).processPacket(handler);
				} catch (Exception ignored) {
				}
			}
		}
	}

	class PosData {
		public float height = 1.9f;
		public float width = 0.4f;
		public int x = 0;
		public int y = 0;
		public int z = 0;
		public double prevX = 0.0;
		public double prevY = 0.0;
		public double prevZ = 0.0;
		private int increment = 0;

		public double getPosX() {
			return x / 32.0;
		}

		public double getPosY() {
			return y / 32.0;
		}

		public double getPosZ() {
			return z / 32.0;
		}

		public void motionX(byte x) {
			prevX = getPosX();
			this.x += x;
			increment = 3;
		}

		public void motionY(byte y) {
			prevY = getPosY();
			this.y += y;
			increment = 3;
		}

		public void motionZ(byte z) {
			prevZ = getPosZ();
			this.z += z;
			increment = 3;
		}

		public void update() {
			if (increment > 0) {
				prevX += ((getPosX()) - prevX) / increment;
				prevY += ((getPosY()) - prevY) / increment;
				prevZ += ((getPosZ()) - prevZ) / increment;
				--increment;
			}
		}
	}
}
