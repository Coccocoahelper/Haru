package cc.unknown.module.impl.exploit;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.network.DisconnectionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.network.PacketEvent.Type;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.network.PacketUtil;
import cc.unknown.utils.network.TimedPacket;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;

@Register(name = "FakeLag", category = Category.Exploit)
public class FakeLag extends Module {

	private Queue<TimedPacket> inbound = new ConcurrentLinkedQueue<>();
	private Queue<TimedPacket> outbound = new ConcurrentLinkedQueue<>();

	public SliderValue inboundDelay = new SliderValue("Inbound Delay", 500, 0, 1000, 10);
	public SliderValue outboundDelay = new SliderValue("Outbound Delay", 500, 0, 1000, 10);
	
	/* Like slinky */

	public FakeLag() {
		this.registerSetting(inboundDelay, outboundDelay);
	}

	@Override
	public void onEnable() {
		inbound.clear();
		outbound.clear();
	}

	@Override
	public void onDisable() {
		if (mc.thePlayer != null && !inbound.isEmpty())
			inbound.forEach(p -> {
				PacketUtil.receivePacketNoEvent((Packet<INetHandler>) p.getPacket());
			});
		inbound.clear();

		if (mc.thePlayer != null && !outbound.isEmpty())
			outbound.forEach(p -> {
				PacketUtil.sendPacketNoEvent(p.getPacket());
			});
		outbound.clear();

	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (e.getType() == Type.RECEIVE) {
			inbound.add(new TimedPacket(e.getPacket()));
			e.setCancelled(true);

			while (!inbound.isEmpty()) {
				if (inbound.peek().getCold().getCum(inboundDelay.getInputToInt())) {
					Packet<?> p = inbound.poll().getPacket();
					PacketUtil.receivePacketNoEvent((Packet<INetHandler>) p);
				} else {
					break;
				}
			}
		}
		
		if (e.getType() == Type.SEND) {
			outbound.add(new TimedPacket(e.getPacket()));
			e.setCancelled(true);
			
			while (!outbound.isEmpty()) {
				if (outbound.peek().getCold().getCum(outboundDelay.getInputToInt())) {
					Packet<?> p = outbound.poll().getPacket();
					PacketUtil.sendPacketNoEvent(p);
				} else {
					break;
				}
			}
		}
	}
	
	@EventLink
	public void onDisconnect(final DisconnectionEvent e) {
		this.disable();
	}

}
