package cc.unknown.module.impl.exploit;

import java.awt.Color;
import java.util.ArrayList;
import java.util.LinkedList;

import org.lwjgl.opengl.GL11;

import cc.unknown.Haru;
import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.PostUpdateEvent;
import cc.unknown.event.impl.other.WorldEvent;
import cc.unknown.event.impl.packet.PacketEvent;
import cc.unknown.event.impl.packet.PacketType;
import cc.unknown.event.impl.player.TickEvent;
import cc.unknown.event.impl.render.Render3DEvent;
import cc.unknown.module.Module;
import cc.unknown.module.impl.ModuleCategory;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.client.Cold;
import cc.unknown.utils.client.ColorUtil;
import cc.unknown.utils.client.RenderUtil;
import cc.unknown.utils.helpers.MathHelper;
import cc.unknown.utils.network.packets.move.PacketEntityLocation;
import cc.unknown.utils.network.packets.move.PacketServerStorage;
import cc.unknown.utils.player.CombatUtil;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.network.OldServerPinger;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.ThreadQuickExitException;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S00PacketKeepAlive;
import net.minecraft.network.play.server.S03PacketTimeUpdate;
import net.minecraft.network.play.server.S0FPacketSpawnMob;
import net.minecraft.network.play.server.S12PacketEntityVelocity;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S18PacketEntityTeleport;
import net.minecraft.network.play.server.S19PacketEntityHeadLook;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.network.play.server.S27PacketExplosion;
import net.minecraft.network.play.server.S32PacketConfirmTransaction;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;
import net.minecraft.world.World;

public class BackTrack extends Module {

	private ModeValue packetMode = new ModeValue("Packet Mode", "Old", "Old", "New");
	private SliderValue maxDelay = new SliderValue("Delay", 150, 25, 1000, 1);
	private SliderValue maxReach = new SliderValue("Reach", 3.4, 2, 6.0, 0.1);
	private BooleanValue onlyCombat = new BooleanValue("Only combat", true);
	private BooleanValue legit = new BooleanValue("Legit", false);
	private BooleanValue renderBox = new BooleanValue("Render Box", true);
	private SliderValue color = new SliderValue("Box Color [H/S/B]", 0, 0, 350, 10);
	private BooleanValue s03 = new BooleanValue("Cancel S03", true);
	private BooleanValue s00 = new BooleanValue("Cancel S00", true);
	private BooleanValue s12 = new BooleanValue("Cancel S12", true);

	private final SliderValue maxHurtTime = new SliderValue("Hurt Resistant Time", 6, 1, 10, 1);
	private final BooleanValue syncHurtTime = new BooleanValue("Sync HurTime with Ping", true);
	private final BooleanValue resetOnVelocity = new BooleanValue("Release on Velocity", true);

	private final ArrayList<Packet<INetHandlerPlayClient>> packets = new ArrayList<>();
	private ArrayList<Entity> storageEntities = new ArrayList<>();
	private LinkedList<PacketEntityLocation> storageEntityMove = new LinkedList<>();
	
	private EntityPlayer entity = null;
	private INetHandler packetListener = null;
	private WorldClient lastWorld;
	private Cold timer = new Cold();

	private long smoothPointer = System.nanoTime();
	private boolean needFreeze = false;

	public BackTrack() {
		super("BackTrack", ModuleCategory.Exploit);
		this.registerSetting(packetMode, maxDelay, maxReach, onlyCombat, legit, renderBox, color, s03, s00, s12, maxHurtTime, syncHurtTime, resetOnVelocity);
	}

	@EventLink
	public void onPreTick(TickEvent.Pre e) {
		if (entity == null) {
			return;
		}
		try {
			if (packetMode.is("Old") && entity != null && mc.thePlayer != null && packetListener != null && mc.theWorld != null) {
				double d0 = (double) Haru.instance.realPosX / 32.0D;
				double d1 = (double) Haru.instance.realPosY / 32.0D;
				double d2 = (double) Haru.instance.realPosZ / 32.0D;
				double d3 = (double) entity.serverPosX / 32.0D;
				double d4 = (double) entity.serverPosY / 32.0D;
				double d5 = (double) entity.serverPosZ / 32.0D;
				AxisAlignedBB alignedBB = new AxisAlignedBB(d3 - (double) entity.width, d4, d5 - (double) entity.width, d3 + (double) entity.width, d4 + (double) entity.height, d5 + (double) entity.width);
				Vec3 positionEyes = mc.thePlayer.getPositionEyes(mc.timer.renderPartialTicks);
				double currentX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB.minX, alignedBB.maxX);
				double currentY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB.minY, alignedBB.maxY);
				double currentZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB.minZ, alignedBB.maxZ);
				AxisAlignedBB alignedBB2 = new AxisAlignedBB(d0 - (double) entity.width, d1, d2 - (double) entity.width, d0 + (double) entity.width, d1 + (double) entity.height, d2 + (double) entity.width);
				double realX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB2.minX, alignedBB2.maxX);
				double realY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB2.minY, alignedBB2.maxY);
				double realZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB2.minZ, alignedBB2.maxZ);
				double distance = maxReach.getInput();
				if (!mc.thePlayer.canEntityBeSeen(entity)) {
					distance = distance > 3 ? 3 : distance;
				}
				double bestX = MathHelper.clamp_double(positionEyes.xCoord, entity.getEntityBoundingBox().minX, entity.getEntityBoundingBox().maxX);
				double bestY = MathHelper.clamp_double(positionEyes.yCoord, entity.getEntityBoundingBox().minY, entity.getEntityBoundingBox().maxY);
				double bestZ = MathHelper.clamp_double(positionEyes.zCoord, entity.getEntityBoundingBox().minZ, entity.getEntityBoundingBox().maxZ);
				boolean b = false;
				if ((positionEyes.distanceTo(new Vec3(bestX, bestY, bestZ)) > 2.9)) {
					b = true;
				}
				if (!legit.isToggled()) {
					b = true;
				}
				if (!(b && positionEyes.distanceTo(new Vec3(realX, realY, realZ)) > positionEyes.distanceTo(new Vec3(currentX, currentY, currentZ)) + 0.05) || !(mc.thePlayer.getDistance(d0, d1, d2) < distance) || timer.reached(maxDelay.getInputToLong())) {
					resetPackets(packetListener);
					timer.reset();
				}

			}
		} catch (Exception ex) {
			entity = null;
		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (e.getType() == PacketType.Send) {
			if (e.getPacket() instanceof C02PacketUseEntity) {
				C02PacketUseEntity c02 = (C02PacketUseEntity) e.getPacket();
				if (onlyCombat.isToggled() && c02.getAction() != C02PacketUseEntity.Action.ATTACK)
					return;
			}
		}

		if (e.getType() == PacketType.Receive) {
			if (packetMode.is("New")) {
				Packet<?> p = e.getPacket();
				WorldClient theWorld = mc.theWorld;
				@SuppressWarnings("unchecked")
				PacketServerStorage storage = new PacketServerStorage((Packet<INetHandlerPlayClient>) p);
				if (p instanceof S14PacketEntity) {
					S14PacketEntity s14Packet = (S14PacketEntity) p;
					Entity entity = (Entity) s14Packet.getEntity(theWorld);
					if (!(entity instanceof EntityPlayer))
						return;
					entity.serverPosX += (int) s14Packet.func_149062_c();
					entity.serverPosY += (int) s14Packet.func_149061_d();
					entity.serverPosZ += (int) s14Packet.func_149064_e();
					double x = entity.serverPosX / 32.0;
					double y = entity.serverPosY / 32.0;
					double z = entity.serverPosZ / 32.0;
					if ((needFreeze) && CombatUtil.instance.canTarget(entity)) {
						AxisAlignedBB afterBB = new AxisAlignedBB(x - 0.4, y - 0.1, z - 0.4, x + 0.4, y + 1.9, z + 0.4);
						Vec3 eyes = mc.thePlayer.getPositionEyes(1F);
						double afterRange = CombatUtil.instance.getNearestPointBB(eyes, afterBB).distanceTo(eyes);
						double beforeRange = CombatUtil.instance.getDistanceToEntity((EntityPlayer) entity);

						if (beforeRange <= 3.2) {
							if (afterRange >= 2.9 && afterRange <= 5.0 && afterRange > beforeRange + 0.02
									&& entity.hurtResistantTime <= calculatedMaxHurtTime()) {
								if (!needFreeze) {
									timer.reset();
									needFreeze = true;
									smoothPointer = System.nanoTime();
								}
								if (!storageEntities.contains(entity))
									storageEntities.add(entity);
								e.setCancelled(true);
								storageEntityMove.add(new PacketEntityLocation(entity, x, y, z));
								return;
							}
						} else {
							if (afterRange <= beforeRange) {
								if (needFreeze)
									releasePackets();
							}
						}
					}
					if (needFreeze) {
						if (!storageEntities.contains(entity))
							storageEntities.add((EntityPlayer) entity);
						storageEntityMove.add(new PacketEntityLocation(entity, x, y, z));
						e.setCancelled(true);
						return;
					}
					if (!e.isCancelled() && !needFreeze) {
						float f = (s14Packet.func_149060_h() ? (s14Packet.func_149066_f() * 360) / 256.0f : entity.rotationYaw);
						float f1 = (s14Packet.func_149060_h() ? (s14Packet.func_149063_g() * 360) / 256.0f : entity.rotationPitch);
						entity.setPositionAndRotation2(x, y, z, f, f1, 3, false);
						entity.onGround = s14Packet.getOnGround();
					}
					e.setCancelled(true);
				} else if (p instanceof S18PacketEntityTeleport) {
					S18PacketEntityTeleport s18Packet = (S18PacketEntityTeleport) p;

					Entity entity = (Entity) theWorld.getEntityByID(s18Packet.getEntityId());
					if (!(entity instanceof EntityPlayer))
						return;
					entity.serverPosX = s18Packet.getX();
					entity.serverPosY = s18Packet.getY();
					entity.serverPosZ = s18Packet.getZ();
					double d0 = entity.serverPosX / 32.0;
					double d1 = entity.serverPosY / 32.0;
					double d2 = entity.serverPosZ / 32.0;
					float f = (s18Packet.getYaw() * 360) / 256.0f;
					float f1 = (s18Packet.getPitch() * 360) / 256.0f;
					if (!needFreeze) {
						if (Math.abs(entity.posX - d0) < 0.03125 && Math.abs(entity.posY - d1) < 0.015625 && Math.abs(entity.posZ - d2) < 0.03125) {
							entity.setPositionAndRotation2(entity.posX, entity.posY, entity.posZ, f, f1, 3, true);
						} else {
							entity.setPositionAndRotation2(d0, d1, d2, f, f1, 3, true);
						}
						entity.onGround = s18Packet.getOnGround();
					} else
						storageEntityMove.add(new PacketEntityLocation(entity, d0, d1, d2));
					e.setCancelled(true);
				} else {
					if ((p instanceof S12PacketEntityVelocity && resetOnVelocity.isToggled())) {
						packets.add(storage.getPacket());
						e.setCancelled(true);
						releasePackets();
						return;
					}
					if (needFreeze && !e.isCancelled()) {
						if (p instanceof S19PacketEntityStatus) {
							if (((S19PacketEntityStatus) p).getOpCode() == 2)
								return;
						}
						packets.add(storage.getPacket());
						e.setCancelled(true);
					}
				}
			} else if (packetMode.is("Old")) {
				if (e.getNetHandler() != null && e.getNetHandler() instanceof OldServerPinger)
					return;
				if (mc.theWorld != null) {

					packetListener = e.getNetHandler();
					synchronized (this) {
						if (e.getPacket() instanceof S14PacketEntity) {
							S14PacketEntity s14Packet = (S14PacketEntity) e.getPacket();
							if (entity != null && s14Packet.getEntity((World) mc.theWorld).equals(entity)) {
								Haru.instance.realPosX += s14Packet.func_149062_c();
								Haru.instance.realPosY += s14Packet.func_149061_d();
								Haru.instance.realPosZ += s14Packet.func_149064_e();
							}
						}
						if (e.getPacket() instanceof S18PacketEntityTeleport) {
							S18PacketEntityTeleport s18Packet = (S18PacketEntityTeleport) e.getPacket();
							if (entity != null && s18Packet.getEntityId() == entity.getEntityId()) {
								Haru.instance.realPosX = s18Packet.getX();
								Haru.instance.realPosY = s18Packet.getY();
								Haru.instance.realPosZ = s18Packet.getZ();
							}
						}

						if (entity == null) {
							resetPackets(e.getNetHandler());
							return;
						}
						if (mc.theWorld != null && mc.thePlayer != null) {
							if (lastWorld != mc.theWorld) {
								resetPackets(e.getNetHandler());
								lastWorld = mc.theWorld;
								return;
							}
							addPackets(e.getPacket(), e);
						}
						lastWorld = mc.theWorld;
					}
				}
			}
		}
	}
	
	@EventLink
	public void onRender3D(Render3DEvent e) {
		if (entity == null) {
			return;
		}
		try {
			if (entity != null && entity != mc.thePlayer && renderBox.isToggled()) {
				final double x = Haru.instance.realPosX / 32.0D - mc.getRenderManager().renderPosX;
				final double y = Haru.instance.realPosY / 32.0D - mc.getRenderManager().renderPosY;
				final double z = Haru.instance.realPosZ / 32.0D - mc.getRenderManager().renderPosZ;
				double widthX = (entity.getEntityBoundingBox().maxX - entity.getEntityBoundingBox().minX) / 2 + 0.05;
				double widthZ = (entity.getEntityBoundingBox().maxZ - entity.getEntityBoundingBox().minZ) / 2 + 0.05;
				double height = (entity.getEntityBoundingBox().maxY - entity.getEntityBoundingBox().minY);

				if (entity instanceof EntityPlayer)
					height *= 1.1;
				RenderUtil.pre3D();
				ColorUtil.setColor(Color.getHSBColor((color.getInputToFloat() % 360) / 360.0f, 1.0f, 1.0f).getRGB(), 1.0f);
				for (int i = 0; i < 2; i++) {
					if (i == 1)
						ColorUtil.setColor(Color.black.getRGB(), 1.0f);
					GL11.glLineWidth(3 - i * 2);
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x - widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y + height, z - widthZ);
					GL11.glVertex3d(x + widthX, y + height, z - widthZ);
					GL11.glVertex3d(x + widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y, z + widthZ);
					GL11.glEnd();
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x + widthX, y, z + widthZ);
					GL11.glVertex3d(x + widthX, y + height, z + widthZ);
					GL11.glVertex3d(x - widthX, y + height, z + widthZ);
					GL11.glVertex3d(x - widthX, y, z + widthZ);
					GL11.glVertex3d(x + widthX, y, z + widthZ);
					GL11.glVertex3d(x + widthX, y, z - widthZ);
					GL11.glEnd();
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x + widthX, y + height, z + widthZ);
					GL11.glVertex3d(x + widthX, y + height, z - widthZ);
					GL11.glEnd();
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x - widthX, y + height, z + widthZ);
					GL11.glVertex3d(x - widthX, y + height, z - widthZ);
					GL11.glEnd();
				}
				RenderUtil.post3D();
			}

		} catch (Exception ex) {

		}
	}
	
	@EventLink
	public void onPost(PostUpdateEvent e) {
	    if (needFreeze && packetMode.is("New")) {
	        doSmoothRelease();
	        if (!storageEntities.isEmpty()) {
	            boolean release = false;
	            for (Entity entity : storageEntities) {
	                double x = entity.serverPosX / 32.0;
	                double y = entity.serverPosY / 32.0;
	                double z = entity.serverPosZ / 32.0;
	                AxisAlignedBB entityBB = new AxisAlignedBB(x - 0.4, y - 0.1, z - 0.4, x + 0.4, y + 1.9, z + 0.4);
	                double range = CombatUtil.instance.getLookingTargetRange(entityBB, mc.thePlayer, null, 6.0);
	                if (range == Double.MAX_VALUE) {
	                    Vec3 eyes = mc.thePlayer.getPositionEyes(1F);
	                    range = CombatUtil.instance.getNearestPointBB(eyes, entityBB).distanceTo(eyes) + 0.075;
	                }
	                if (range <= 2.9) {
	                    release = true;
	                    break;
	                }
	                Entity entity1 = entity;
	                if (entity1 != entity)
	                    continue;
	                if (timer.reached(100)) {
	                    if (range >= 2.9) {
	                        release = true;
	                        break;
	                    }
	                }
	            }
	            if (release)
	                releasePackets();
	        }
	    }
	}
	
	@EventLink
	public void onWorld(WorldEvent e) {
		entity = null;
	    storageEntities.clear();
	    if (e.getWorldClient() == null)
	        packets.clear();
	}

	private void releasePackets() {
		entity = null;
	    smoothPointer = System.nanoTime();
	    INetHandlerPlayClient netHandler = mc.getNetHandler();
	    if (packets.isEmpty())
	        return;
	    while (!packets.isEmpty()) {
	        Packet<INetHandlerPlayClient> packet = packets.remove(0);
	        try {
	        	packet.processPacket(netHandler);
	        } catch (ThreadQuickExitException ignored) {
	        }
	    }
	    while (!storageEntities.isEmpty()) {
	        Entity entity = storageEntities.remove(0);
	        if (!( entity).isDead) {
	            double x = entity.serverPosX / 32.0;
	            double y = entity.serverPosY / 32.0;
	            double z = entity.serverPosZ / 32.0;
	            entity.setPosition(x, y, z);
	        }
	    }
	    needFreeze = false;
	}
	
	private void doSmoothRelease() {
	    boolean found = false;
	    long bestTimeStamp = Math.max(smoothPointer, System.nanoTime() - 200 * 1000000);
	    Vec3 eyesLoc = new Vec3(mc.thePlayer.posX, mc.thePlayer.posY + mc.thePlayer.getEyeHeight(), mc.thePlayer.posZ);
	    for (PacketEntityLocation it : storageEntityMove) {
	        if (CombatUtil.instance.isValidTarget((EntityPlayer) it.getEntity())) {
	            found = true;
	            double width = it.getEntity().width / 2.0;
	            double height = it.getEntity().height;
	            AxisAlignedBB bb = new AxisAlignedBB(it.getX() - width, it.getY(), it.getZ() - width, it.getX() + width, it.getY() + height, it.getZ() + width).expand(0.1, height, width);
	            double closestX = Math.max(bb.minX, Math.min(eyesLoc.xCoord, bb.maxX));
	            double closestY = Math.max(bb.minY, Math.min(eyesLoc.yCoord, bb.maxY));
	            double closestZ = Math.max(bb.minZ, Math.min(eyesLoc.zCoord, bb.maxZ));
	            double distanceToBoundingBox = Math.sqrt(Math.pow(eyesLoc.xCoord - closestX, 2) + Math.pow(eyesLoc.yCoord - closestY, 2) + Math.pow(eyesLoc.zCoord - closestZ, 2));
	            double range = eyesLoc.distanceTo(new Vec3(bb.minX + (bb.maxX - bb.minX) / 2.0, bb.minY + (bb.maxY - bb.minY) / 2.0, bb.minZ + (bb.maxZ - bb.minZ) / 2.0));
	            if (range < 2.9 || distanceToBoundingBox < 2.8) {
	                bestTimeStamp = Math.max(bestTimeStamp, it.getTime());
	            }
	        }
	    }

	    if (!found) {
	        releasePackets();
	    }
	}

	private int calculatedMaxHurtTime() {
		int ping = CombatUtil.instance.getPing(mc.thePlayer);

		return maxHurtTime.getInputToInt() + (syncHurtTime.isToggled() ? (int) Math.ceil(ping / 50.0) : 0);
	}

	private void resetPackets(INetHandler netHandler) {
		if (packets.size() > 0) {
			synchronized (packets) {
				while (packets.size() != 0) {
					try {
						packets.get(0).processPacket((INetHandlerPlayClient) netHandler);
					} catch (Exception ignored) {
					}
					packets.remove(packets.get(0));
				}

			}
		}
	}

	private void addPackets(Packet<INetHandlerPlayClient> packet, PacketEvent e) {
		synchronized (packets) {
			if (blockPacket(packet)) {
				packets.add(packet);
				e.setCancelled(true);
			}
		}
	}

	private boolean blockPacket(Packet<INetHandlerPlayClient> packet) {
		if (packet instanceof S03PacketTimeUpdate) {
			return s03.isToggled();
		} else if (packet instanceof S00PacketKeepAlive) {
			return s00.isToggled();
		} else if (packet instanceof S12PacketEntityVelocity || packet instanceof S27PacketExplosion) {
			return s12.isToggled();
		} else {
			return packet instanceof S32PacketConfirmTransaction || packet instanceof S14PacketEntity
					|| packet instanceof S19PacketEntityStatus || packet instanceof S19PacketEntityHeadLook
					|| packet instanceof S18PacketEntityTeleport || packet instanceof S0FPacketSpawnMob;
		}
	}
}
