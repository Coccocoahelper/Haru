package cc.unknown.module.impl.exploit;

import java.util.ArrayList;

import cc.unknown.event.impl.api.EventLink;
import cc.unknown.event.impl.move.PostUpdateEvent;
import cc.unknown.event.impl.other.WorldEvent;
import cc.unknown.event.impl.packet.PacketEvent;
import cc.unknown.module.Module;
import cc.unknown.module.impl.ModuleCategory;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.DoubleSliderValue;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.client.AdvancedTimer;
import cc.unknown.utils.helpers.MathHelper;
import net.minecraft.client.network.NetworkPlayerInfo;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.item.EntityArmorStand;
import net.minecraft.entity.monster.EntityMob;
import net.minecraft.entity.passive.EntityAnimal;
import net.minecraft.entity.passive.EntityVillager;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.network.play.server.S12PacketEntityVelocity;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;

@SuppressWarnings("unchecked")
public class BackTrack extends Module {

	private ModeValue mode = new ModeValue("Mode", "Receive", "Receive", "Send");
	private final SliderValue minRange = new SliderValue("Min Range", 2.9, 0.0, 6.0, 0.1);
	private final SliderValue maxStartRange = new SliderValue("Max Start Range", 3.2, 2.0, 4.0, 0.1);
	private final SliderValue maxActiveRange = new SliderValue("Max Active Range", 5.0, 2.0, 6.0, 0.5);
	private final DoubleSliderValue delay = new DoubleSliderValue("Delay", 100, 500, 0, 5000, 10);
	private final SliderValue maxHurtTime = new SliderValue("Max Hurt Time", 6, 0, 10, 1);
	private final BooleanValue syncHurtTime = new BooleanValue("Sync HurtTime with Ping", true);
	private final SliderValue minReleaseRange = new SliderValue("Min Release Range", 3.2, 2.0, 6.0, 0.1);
	private final BooleanValue resetOnVelocity = new BooleanValue("Release on Velocity", true);
	private final BooleanValue resetOnLagging = new BooleanValue("Release on Flag", true);

	private final ArrayList<Packet<INetHandler>> storedPackets = new ArrayList<>();
	private final ArrayList<Entity> targets = new ArrayList<>();
	private AdvancedTimer freezeTimer = new AdvancedTimer(0);
	private Entity targetEntity = null;
	private boolean freezingNeeded = false;

	public BackTrack() {
		super("BackTrack", ModuleCategory.Exploit);
		this.registerSetting(mode, minRange, maxStartRange, maxActiveRange, delay, maxHurtTime, syncHurtTime, minReleaseRange,
				resetOnVelocity, resetOnLagging);

	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if ((e.isSend() && mode.is("Send")) || (e.isReceive() && mode.is("Receive"))) {

			if (mc.thePlayer == null || mc.theWorld == null) {
				return;
			}

			if (e.getPacket() instanceof S14PacketEntity) {
				S14PacketEntity entityPacket = (S14PacketEntity) e.getPacket();
				Entity entity = entityPacket.getEntity(mc.theWorld);

				entity.serverPosX += entityPacket.func_149062_c();
				entity.serverPosY += entityPacket.func_149061_d();
				entity.serverPosZ += entityPacket.func_149064_e();

				double x = entity.serverPosX / 32.0;
				double y = entity.serverPosY / 32.0;
				double z = entity.serverPosZ / 32.0;

				boolean isValidTarget = isValidWithPlayer(entity, 100, true, true, false, false);

				if (isValidTarget) {
					double afterRange = calculateAfterRange(x, y, z);
					double beforeRange = calculateBeforeRange(entity);

					if (beforeRange <= maxStartRange.getInputToFloat()
							&& isInRange(afterRange, minRange.getInputToFloat(), maxActiveRange.getInputToFloat())
							&& afterRange > beforeRange + 0.02
							&& ((EntityLivingBase) entity).hurtTime <= calculateMaxHurtTime()) {
						if (!freezingNeeded) {
							freezeTimer.reset();
							freezingNeeded = true;
						}
						if (!targets.contains(entity)) {
							targets.add(entity);
						}
						e.setCancelled(true);
						return;
					}
				}

				if (freezingNeeded) {
					if (!targets.contains(entity)) {
						targets.add(entity);
					}
					e.setCancelled(true);
					return;
				}

				float f = entityPacket.func_149060_h() ? (entityPacket.func_149066_f() * 360) / 256.0f
						: entity.rotationYaw;
				float f1 = entityPacket.func_149060_h() ? (entityPacket.func_149063_g() * 360) / 256.0f
						: entity.rotationPitch;

				entity.setPositionAndRotation2(x, y, z, f, f1, 3, false);
				entity.onGround = entityPacket.getOnGround();
				e.setCancelled(true);

			} else {
				if ((e.getPacket() instanceof S12PacketEntityVelocity && resetOnVelocity.isToggled())
						|| (e.getPacket() instanceof S08PacketPlayerPosLook && resetOnLagging.isToggled())) {
					storedPackets.add((Packet<INetHandler>) e.getPacket());
					e.setCancelled(true);
					releasePackets();
				} else if (freezingNeeded && !e.isCancelled()) {
					if (e.getPacket() instanceof S19PacketEntityStatus) {
						if (((S19PacketEntityStatus) e.getPacket()).getOpCode() == (byte) 2) {
							return;
						}
					}
					storedPackets.add((Packet<INetHandler>) e.getPacket());
					e.setCancelled(true);

				}
			}
		} else if (e.getPacket() instanceof C02PacketUseEntity) {
			C02PacketUseEntity useEntityPacket = (C02PacketUseEntity) e.getPacket();
			if (useEntityPacket.getAction() == C02PacketUseEntity.Action.ATTACK && freezingNeeded) {
				targetEntity = useEntityPacket.getEntityFromWorld(mc.theWorld);
			}
		}
	}

	@EventLink
	public void onMotion(PostUpdateEvent e) {
		if (freezingNeeded) {
			if (freezeTimer.reached(delay.getInputMaxToLong())) {
				releasePackets();
				return;
			}

			if (!targets.isEmpty()) {
				boolean shouldRelease = false;

				for (Entity entity : targets) {
					double x = entity.serverPosX / 32.0;
					double y = entity.serverPosY / 32.0;
					double z = entity.serverPosZ / 32.0;

					AxisAlignedBB entityBB = new AxisAlignedBB(x - 0.4, y - 0.1, z - 0.4, x + 0.4, y + 1.9, z + 0.4);

					double range = mc.thePlayer.getDistanceToEntity(mc.thePlayer);

					if (range == Double.MAX_VALUE) {
						Vec3 eyes = mc.thePlayer.getPositionEyes(1F);
						range = getNearestPointBB(eyes, entityBB).distanceTo(eyes) + 0.075;
					}

					if (range <= minRange.getInputToFloat()) {
						shouldRelease = true;
						break;
					}

					Entity entity1 = targetEntity;
					if (entity1 != entity) {
						continue;
					}

					if (freezeTimer.reached(delay.getInputMinToLong())) {
						if (range >= minReleaseRange.getInputToFloat()) {
							shouldRelease = true;
							break;
						}
					}
				}

				if (shouldRelease) {
					releasePackets();
				}
			}
		}
	}

	@EventLink
	public void onWorld(WorldEvent e) {
		targetEntity = null;
		targets.clear();

		if (e.getWorldClient() == null) {
			storedPackets.clear();
		}
	}

	private double calculateAfterRange(double x, double y, double z) {
		AxisAlignedBB afterBB = new AxisAlignedBB(x - 0.4, y - 0.1, z - 0.4, x + 0.4, y + 1.9, z + 0.4);
		Vec3 eyes = mc.thePlayer.getPositionEyes(1F);
		return getNearestPointBB(eyes, afterBB).distanceTo(eyes);
	}

	private double calculateBeforeRange(Entity entity) {
		return getDistanceToEntityBox(mc.thePlayer, entity);
	}

	private boolean isInRange(double value, double minValue, double maxValue) {
		return value >= minValue && value <= maxValue;
	}

	public void releasePackets() {
		targetEntity = null;

		if (storedPackets.isEmpty()) {
			return;
		}

		while (!storedPackets.isEmpty()) {
			Packet<INetHandler> packet = storedPackets.remove(0);
			packet.processPacket(mc.getNetHandler());
		}

		while (!targets.isEmpty()) {
			Entity entity = targets.remove(0);

			if (!entity.isDead) {
				double x = entity.serverPosX / 32.0;
				double y = entity.serverPosY / 32.0;
				double z = entity.serverPosZ / 32.0;

				entity.setPosition(x, y, z);
			}
		}

		freezingNeeded = false;
	}

	private int calculateMaxHurtTime() {
		int ping = getPing(mc.thePlayer);
		return maxHurtTime.getInputToInt() + (syncHurtTime.isToggled() ? (int) Math.ceil(ping / 50.0) : 0);
	}

	private Vec3 getNearestPointBB(Vec3 eye, AxisAlignedBB box) {
		double[] origin = { eye.xCoord, eye.yCoord, eye.zCoord };
		double[] destMins = { box.minX, box.minY, box.minZ };
		double[] destMaxs = { box.maxX, box.maxY, box.maxZ };

		for (int i = 0; i < 3; i++) {
			if (origin[i] > destMaxs[i]) {
				origin[i] = destMaxs[i];
			} else if (origin[i] < destMins[i]) {
				origin[i] = destMins[i];
			}
		}

		return new Vec3(origin[0], origin[1], origin[2]);
	}

	private boolean isValidWithPlayer(Entity entity, float range, boolean invis, boolean players, boolean animals,
			boolean mobs) {
		return !(entity.isDead || entity == null || !(entity instanceof EntityLivingBase)
				|| mc.thePlayer == entity && mc.gameSettings.thirdPersonView == 0 || getRange(entity) > range
				|| entity instanceof EntityArmorStand || entity instanceof EntityVillager
				|| entity instanceof EntityPlayer && !players || entity instanceof EntityAnimal && !animals
				|| entity instanceof EntityMob && !mobs || entity.isInvisible() && !invis
				|| mc.theWorld.getEntityByID(entity.getEntityId()) != entity || entity == null);
	}

	private double getRange(Entity entity) {
		if (mc.thePlayer == null)
			return 0;
		return mc.thePlayer.getPositionEyes(1.0f)
				.distanceTo(getBestVector(mc.thePlayer.getPositionEyes(1F), entity.getEntityBoundingBox()));
	}

	private Vec3 getBestVector(Vec3 look, AxisAlignedBB axisAlignedBB) {
		return new Vec3(MathHelper.clamp_double(look.xCoord, axisAlignedBB.minX, axisAlignedBB.maxX),
				MathHelper.clamp_double(look.yCoord, axisAlignedBB.minY, axisAlignedBB.maxY),
				MathHelper.clamp_double(look.zCoord, axisAlignedBB.minZ, axisAlignedBB.maxZ));
	}

	private double getDistanceToEntityBox(Entity entity1, Entity entity2) {
		Vec3 eyes = entity1.getPositionEyes(1.0F);
		Vec3 pos = getNearestPointBB(eyes, entity2.getEntityBoundingBox());
		double xDist = Math.abs(pos.xCoord - eyes.xCoord);
		double yDist = Math.abs(pos.yCoord - eyes.yCoord);
		double zDist = Math.abs(pos.zCoord - eyes.zCoord);
		return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2) + Math.pow(zDist, 2));
	}

	private int getPing(EntityPlayer player) {
		NetworkPlayerInfo playerInfo = mc.getNetHandler().getPlayerInfo(player.getUniqueID());
		return playerInfo != null ? playerInfo.getResponseTime() : 0;
	}
}
