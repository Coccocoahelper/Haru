package cc.unknown.module.impl.exploit;

import java.util.ArrayList;

import cc.unknown.Haru;
import cc.unknown.event.impl.api.EventLink;
import cc.unknown.event.impl.move.PostUpdateEvent;
import cc.unknown.event.impl.other.WorldEvent;
import cc.unknown.event.impl.packet.PacketEvent;
import cc.unknown.event.impl.packet.PacketType;
import cc.unknown.event.impl.player.PreTickEvent;
import cc.unknown.mixin.interfaces.packet.IS14PacketEntity;
import cc.unknown.module.Module;
import cc.unknown.module.impl.ModuleCategory;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.DoubleSliderValue;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.client.AdvancedTimer;
import cc.unknown.utils.helpers.MathHelper;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.network.NetworkPlayerInfo;
import net.minecraft.client.network.OldServerPinger;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.item.EntityArmorStand;
import net.minecraft.entity.monster.EntityMob;
import net.minecraft.entity.passive.EntityAnimal;
import net.minecraft.entity.passive.EntityVillager;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.server.S00PacketKeepAlive;
import net.minecraft.network.play.server.S03PacketTimeUpdate;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.network.play.server.S0FPacketSpawnMob;
import net.minecraft.network.play.server.S12PacketEntityVelocity;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S18PacketEntityTeleport;
import net.minecraft.network.play.server.S19PacketEntityHeadLook;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.network.play.server.S27PacketExplosion;
import net.minecraft.network.play.server.S32PacketConfirmTransaction;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;

@SuppressWarnings("unchecked")
public class BackTrack extends Module {

	private ModeValue mode = new ModeValue("Mode", "New", "New", "Old");

	// Old
	private ModeValue packetMode = new ModeValue("Packets", "All", "All", "Basic");
	private SliderValue delay = new SliderValue("Delay", 450, 0, 5000, 1);
	private SliderValue maximumRange = new SliderValue("Max Range", 6, 1, 6, 1);
	private BooleanValue onlyWhenNeeded = new BooleanValue("Only When Out of Reach", true);

	// New
	private final SliderValue minRange = new SliderValue("Min Range", 2.9, 0.0, 6.0, 0.1);
	private final SliderValue maxStartRange = new SliderValue("Max Start Range", 3.2, 2.0, 4.0, 0.1);
	private final SliderValue maxActiveRange = new SliderValue("Max Active Range", 5.0, 2.0, 6.0, 0.5);
	private final DoubleSliderValue gdelay = new DoubleSliderValue("Delay", 100, 500, 0, 5000, 10);
	private final SliderValue maxHurtTime = new SliderValue("Max Hurt Time", 6, 0, 10, 1);
	private final BooleanValue syncHurtTime = new BooleanValue("Sync HurtTime with Ping", true);
	private final SliderValue minReleaseRange = new SliderValue("Min Release Range", 3.2, 2.0, 6.0, 0.1);
	private final BooleanValue resetOnVelocity = new BooleanValue("Release on Velocity", true);
	private final BooleanValue resetOnLagging = new BooleanValue("Release on Flag", true);

	// Old
	private final ArrayList<Packet<INetHandler>> packets = new ArrayList<>();
	private EntityLivingBase entity = null;
	private INetHandler packetListener = null;
	private WorldClient lastWorld;
	private final AdvancedTimer timeHelper = new AdvancedTimer(0);

	// New
	private final ArrayList<Packet<INetHandler>> storedPackets = new ArrayList<>();
	private final ArrayList<Entity> targets = new ArrayList<>();
	private AdvancedTimer freezeTimer = new AdvancedTimer(0);
	private Entity targetEntity = null;
	private boolean freezingNeeded = false;

	public BackTrack() {
		super("BackTrack", ModuleCategory.Exploit);
		this.registerSetting(mode, packetMode, delay, maximumRange, onlyWhenNeeded, minRange, maxStartRange, maxActiveRange, gdelay, maxHurtTime, syncHurtTime,
				minReleaseRange, resetOnVelocity, resetOnLagging);

	}

	@EventLink
	public void onRunTick(PreTickEvent e) {
		if (mode.is("Old")) {
			try {
				if (entity != null && mc.thePlayer != null && packetListener != null && mc.theWorld != null) {
					double d0 = Haru.instance.getRealPosX() / 32.0D;
					double d1 = Haru.instance.getRealPosY() / 32.0D;
					double d2 = Haru.instance.getRealPosZ() / 32.0D;
					double d3 = (double) entity.serverPosX / 32.0D;
					double d4 = (double) entity.serverPosY / 32.0D;
					double d5 = (double) entity.serverPosZ / 32.0D;
					AxisAlignedBB alignedBB = new AxisAlignedBB(d3 - (double) entity.width, d4,
							d5 - (double) entity.width, d3 + (double) entity.width,
							d4 + (double) entity.height, d5 + (double) entity.width);
					Vec3 positionEyes = mc.thePlayer.getPositionEyes(mc.timer.renderPartialTicks);
					double currentX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB.minX, alignedBB.maxX);
					double currentY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB.minY, alignedBB.maxY);
					double currentZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB.minZ, alignedBB.maxZ);
					AxisAlignedBB alignedBB2 = new AxisAlignedBB(d0 - (double) entity.width, d1,
							d2 - (double) entity.width, d0 + (double) entity.width,
							d1 + (double) entity.height, d2 + (double) entity.width);
					double realX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB2.minX, alignedBB2.maxX);
					double realY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB2.minY, alignedBB2.maxY);
					double realZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB2.minZ, alignedBB2.maxZ);
					double distance = maximumRange.getInput();
					if (!mc.thePlayer.canEntityBeSeen(entity)) {
						distance = distance > 3 ? 3 : distance;
					}
					double bestX = MathHelper.clamp_double(positionEyes.xCoord, entity.getEntityBoundingBox().minX,
							entity.getEntityBoundingBox().maxX);
					double bestY = MathHelper.clamp_double(positionEyes.yCoord, entity.getEntityBoundingBox().minY,
							entity.getEntityBoundingBox().maxY);
					double bestZ = MathHelper.clamp_double(positionEyes.zCoord, entity.getEntityBoundingBox().minZ,
							entity.getEntityBoundingBox().maxZ);
					boolean b = positionEyes.distanceTo(new Vec3(bestX, bestY, bestZ)) > 2.9
							|| (mc.thePlayer.hurtTime < 8 && mc.thePlayer.hurtTime > 1);
					if (!onlyWhenNeeded.isToggled()) {
						b = true;
					}
					if (!(b && positionEyes.distanceTo(new Vec3(realX, realY, realZ)) > positionEyes
							.distanceTo(new Vec3(currentX, currentY, currentZ)) + 0.05)
							|| !(mc.thePlayer.getDistance(d0, d1, d2) < distance)
							|| timeHelper.reached((long) delay.getInput())) {
						resetPackets(packetListener);
						timeHelper.reset();
					}
				}
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (mc.thePlayer == null || mc.theWorld == null) {
			return;
		}

		if (mode.is("New")) {
			Packet<?> packet = e.getPacket();
			WorldClient theWorld = mc.theWorld;

			if (e.getType() == PacketType.Receive) {
				if (packet instanceof S14PacketEntity) {
					S14PacketEntity entityPacket = (S14PacketEntity) packet;
					Entity entity = entityPacket.getEntity(theWorld);

					if (entity == null || !(entity instanceof EntityLivingBase)) {
						return;
					}

					entity.serverPosX += entityPacket.func_149062_c();
					entity.serverPosY += entityPacket.func_149061_d();
					entity.serverPosZ += entityPacket.func_149064_e();

					double x = entity.serverPosX / 32.0;
					double y = entity.serverPosY / 32.0;
					double z = entity.serverPosZ / 32.0;

					boolean isValidTarget = freezingNeeded && isValidWithPlayer(entity, 100, true, true, false, false);

					if (isValidTarget) {
						double afterRange = calculateAfterRange(x, y, z);
						double beforeRange = calculateBeforeRange(entity);

						if (beforeRange <= maxStartRange.getInputToFloat()
								&& isInRange(afterRange, minRange.getInput(), maxActiveRange.getInput())
								&& afterRange > beforeRange + 0.02
								&& ((EntityLivingBase) entity).hurtTime <= calculateMaxHurtTime()) {
							if (!freezingNeeded) {
								freezeTimer.reset();
								freezingNeeded = true;
							}
							if (!targets.contains(entity)) {
								targets.add(entity);
							}
							e.setCancelled(true);
							return;
						}
					}

					if (freezingNeeded) {
						if (!targets.contains(entity)) {
							targets.add(entity);
						}
						e.setCancelled(true);
						return;
					}

					float f = entityPacket.func_149060_h() ? (entityPacket.func_149066_f() * 360) / 256.0f : entity.rotationYaw;
					float f1 = entityPacket.func_149060_h() ? (entityPacket.func_149063_g() * 360) / 256.0f : entity.rotationPitch;

					entity.setPositionAndRotation2(x, y, z, f, f1, 3, false);
					entity.onGround = entityPacket.getOnGround();
					e.setCancelled(true);
				} else {
					if ((packet instanceof S12PacketEntityVelocity && resetOnVelocity.isToggled())
							|| (packet instanceof S08PacketPlayerPosLook && resetOnLagging.isToggled())) {
						storedPackets.add((Packet<INetHandler>) packet);
						e.setCancelled(true);
						releasePackets();
					} else if (freezingNeeded && !e.isCancelled()) {
						if (packet instanceof S19PacketEntityStatus) {
							if (((S19PacketEntityStatus) packet).getOpCode() == (byte) 2) {
								return;
							}
						}
						storedPackets.add((Packet<INetHandler>) packet);
						e.setCancelled(true);
					}
				}
			} else if (packet instanceof C02PacketUseEntity) {
				C02PacketUseEntity useEntityPacket = (C02PacketUseEntity) packet;
				if (useEntityPacket.getAction() == C02PacketUseEntity.Action.ATTACK && freezingNeeded) {
					targetEntity = useEntityPacket.getEntityFromWorld(theWorld);
				}
			}
		} else if (mode.is("Old")) {
			if (mc.getNetHandler().getNetworkManager().getNetHandler() != null
					&& mc.getNetHandler().getNetworkManager().getNetHandler() instanceof OldServerPinger)
				return;
			if (mc.theWorld != null) {
				if (e.getType() == PacketType.Receive) {
					packetListener = mc.getNetHandler().getNetworkManager().getNetHandler();
					synchronized (this) {
						final Packet<?> p = e.getPacket();
						if (p instanceof S14PacketEntity) {
							S14PacketEntity packetEntity = (S14PacketEntity) p;
							final Entity entity = mc.theWorld
									.getEntityByID(((IS14PacketEntity) packetEntity).getEntityId());
							if (entity instanceof EntityLivingBase) {
								Haru.instance.setRealPosX(Haru.instance.getRealPosX() + packetEntity.func_149062_c());
								Haru.instance.setRealPosY(Haru.instance.getRealPosY() + packetEntity.func_149061_d());
								Haru.instance.setRealPosZ(Haru.instance.getRealPosZ() + packetEntity.func_149064_e());
							}
						}
						if (p instanceof S18PacketEntityTeleport) {
							S18PacketEntityTeleport teleportPacket = (S18PacketEntityTeleport) p;
							final Entity entity = mc.theWorld.getEntityByID(teleportPacket.getEntityId());
							if (entity instanceof EntityLivingBase) {
								Haru.instance.setRealPosX(teleportPacket.getX());
								Haru.instance.setRealPosY(teleportPacket.getY());
								Haru.instance.setRealPosZ(teleportPacket.getZ());
							}
						}

						entity = null;
						if (entity == null) {
							resetPackets(mc.getNetHandler().getNetworkManager().getNetHandler());
							return;
						}
						if (mc.theWorld != null && mc.thePlayer != null) {
							if (lastWorld != mc.theWorld) {
								resetPackets(mc.getNetHandler().getNetworkManager().getNetHandler());
								lastWorld = mc.theWorld;
								return;
							}
							synchronized (packets) {
								if (blockPacket(p)) {
									packets.add((Packet<INetHandler>) p);
									e.setCancelled(true);
								}
							}
						}
						lastWorld = mc.theWorld;
					}
				}
			}
		}
	}

	private void resetPackets(INetHandler netHandler) {
		if (packets.size() > 0) {
			synchronized (packets) {
				while (packets.size() != 0) {
					try {
						packets.get(0).processPacket(netHandler);
					} catch (Exception ignored) {
					}
					packets.remove(packets.get(0));
				}

			}
		}
	}

	private boolean blockPacket(Packet<?> packet) {
		switch (packetMode.getMode()) {
		case "All":
			return true;
		default:
			if (packet instanceof S03PacketTimeUpdate) {
				return true;
			} else if (packet instanceof S00PacketKeepAlive) {
				return true;
			} else if (packet instanceof S12PacketEntityVelocity || packet instanceof S27PacketExplosion) {
				return true;
			} else {
				return packet instanceof S32PacketConfirmTransaction || packet instanceof S14PacketEntity
						|| packet instanceof S19PacketEntityStatus || packet instanceof S19PacketEntityHeadLook
						|| packet instanceof S18PacketEntityTeleport || packet instanceof S0FPacketSpawnMob;
			}
		}
	}

	@EventLink
	public void onMotion(PostUpdateEvent event) {
		if (freezingNeeded && mode.is("New")) {
			if (freezeTimer.reached(gdelay.getInputMaxToLong())) {
				releasePackets();
				return;
			}

			if (!targets.isEmpty()) {
				boolean shouldRelease = false;

				for (Entity entity : targets) {
					double x = entity.serverPosX / 32.0;
					double y = entity.serverPosY / 32.0;
					double z = entity.serverPosZ / 32.0;

					AxisAlignedBB entityBB = new AxisAlignedBB(x - 0.4, y - 0.1, z - 0.4, x + 0.4, y + 1.9, z + 0.4);

					double range = mc.thePlayer.getDistanceSqToEntity(mc.thePlayer);

					if (range == Double.MAX_VALUE) {
						Vec3 eyes = mc.thePlayer.getPositionEyes(1F);
						range = getNearestPointBB(eyes, entityBB).distanceTo(eyes) + 0.075;
					}

					if (range <= minRange.getInputToFloat()) {
						shouldRelease = true;
						break;
					}

					Entity entity1 = targetEntity;
					if (entity1 != entity) {
						continue;
					}

					if (freezeTimer.reached(gdelay.getInputMinToLong())) {
						if (range >= minReleaseRange.getInput()) {
							shouldRelease = true;
							break;
						}
					}
				}

				if (shouldRelease) {
					releasePackets();
				}
			}
		}
	}

	@EventLink
	public void onWorld(WorldEvent e) {
		targetEntity = null;
		targets.clear();

		if (e.getWorldClient() == null) {
			storedPackets.clear();
		}
	}

	private double calculateAfterRange(double x, double y, double z) {
		AxisAlignedBB afterBB = new AxisAlignedBB(x - 0.4, y - 0.1, z - 0.4, x + 0.4, y + 1.9, z + 0.4);
		Vec3 eyes = mc.thePlayer.getPositionEyes(1F);
		return getNearestPointBB(eyes, afterBB).distanceTo(eyes);
	}

	private double calculateBeforeRange(Entity entity) {
		return getDistanceToEntityBox(mc.thePlayer, entity);
	}

	private boolean isInRange(double value, double minValue, double maxValue) {
		return value >= minValue && value <= maxValue;
	}

	public void releasePackets() {
		targetEntity = null;

		if (storedPackets.isEmpty()) {
			return;
		}

		while (!storedPackets.isEmpty()) {
			Packet<INetHandler> packet = storedPackets.remove(0);
			packet.processPacket(mc.getNetHandler());
		}

		while (!targets.isEmpty()) {
			Entity entity = targets.remove(0);

			if (!entity.isDead) {
				double x = entity.serverPosX / 32.0;
				double y = entity.serverPosY / 32.0;
				double z = entity.serverPosZ / 32.0;

				entity.setPosition(x, y, z);
			}
		}

		freezingNeeded = false;
	}

	private int calculateMaxHurtTime() {
		int ping = getPing(mc.thePlayer);
		return maxHurtTime.getInputToInt() + (syncHurtTime.isToggled() ? (int) Math.ceil(ping / 50.0) : 0);
	}

	private Vec3 getNearestPointBB(Vec3 eye, AxisAlignedBB box) {
		double[] origin = { eye.xCoord, eye.yCoord, eye.zCoord };
		double[] destMins = { box.minX, box.minY, box.minZ };
		double[] destMaxs = { box.maxX, box.maxY, box.maxZ };

		for (int i = 0; i < 3; i++) {
			if (origin[i] > destMaxs[i]) {
				origin[i] = destMaxs[i];
			} else if (origin[i] < destMins[i]) {
				origin[i] = destMins[i];
			}
		}

		return new Vec3(origin[0], origin[1], origin[2]);
	}

	private boolean isValidWithPlayer(Entity entity, float range, boolean invis, boolean players, boolean animals,
			boolean mobs) {
		return !(entity.isDead || entity == null || !(entity instanceof EntityLivingBase)
				|| mc.thePlayer == entity && mc.gameSettings.thirdPersonView == 0 || getRange(entity) > range
				|| entity instanceof EntityArmorStand || entity instanceof EntityVillager
				|| entity instanceof EntityPlayer && !players || entity instanceof EntityAnimal && !animals
				|| entity instanceof EntityMob && !mobs || entity.isInvisible() && !invis
				|| mc.theWorld.getEntityByID(entity.getEntityId()) != entity || entity == null);
	}

	private double getRange(Entity entity) {
		if (mc.thePlayer == null)
			return 0;
		return mc.thePlayer.getPositionEyes(1.0f)
				.distanceTo(getBestVector(mc.thePlayer.getPositionEyes(1F), entity.getEntityBoundingBox()));
	}

	private Vec3 getBestVector(Vec3 look, AxisAlignedBB axisAlignedBB) {
		return new Vec3(MathHelper.clamp_double(look.xCoord, axisAlignedBB.minX, axisAlignedBB.maxX),
				MathHelper.clamp_double(look.yCoord, axisAlignedBB.minY, axisAlignedBB.maxY),
				MathHelper.clamp_double(look.zCoord, axisAlignedBB.minZ, axisAlignedBB.maxZ));
	}

	private double getDistanceToEntityBox(Entity entity1, Entity entity2) {
		Vec3 eyes = entity1.getPositionEyes(1.0F);
		Vec3 pos = getNearestPointBB(eyes, entity2.getEntityBoundingBox());
		double xDist = Math.abs(pos.xCoord - eyes.xCoord);
		double yDist = Math.abs(pos.yCoord - eyes.yCoord);
		double zDist = Math.abs(pos.zCoord - eyes.zCoord);
		return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2) + Math.pow(zDist, 2));
	}

	private int getPing(EntityPlayer player) {
		NetworkPlayerInfo playerInfo = mc.getNetHandler().getPlayerInfo(player.getUniqueID());
		return playerInfo != null ? playerInfo.getResponseTime() : 0;
	}
}
