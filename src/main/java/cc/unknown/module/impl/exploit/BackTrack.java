package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedList;

import cc.unknown.Haru;
import cc.unknown.event.impl.api.EventLink;
import cc.unknown.event.impl.packet.PacketEvent;
import cc.unknown.event.impl.packet.PacketType;
import cc.unknown.event.impl.player.PreTickEvent;
import cc.unknown.module.Module;
import cc.unknown.module.impl.ModuleCategory;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.client.AdvancedTimer;
import cc.unknown.utils.helpers.MathHelper;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.network.OldServerPinger;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.server.S00PacketKeepAlive;
import net.minecraft.network.play.server.S03PacketTimeUpdate;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.network.play.server.S0FPacketSpawnMob;
import net.minecraft.network.play.server.S12PacketEntityVelocity;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S18PacketEntityTeleport;
import net.minecraft.network.play.server.S19PacketEntityHeadLook;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.network.play.server.S27PacketExplosion;
import net.minecraft.network.play.server.S32PacketConfirmTransaction;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;

public class BackTrack extends Module {

	private AdvancedTimer timeHelper = new AdvancedTimer(0);
	private final ArrayList<Packet<INetHandler>> packets = new ArrayList<>();

	private final LinkedList<Packet<?>> pospacket = new LinkedList<>();

	private EntityLivingBase entity = null;

	private WorldClient lastWorld;

	private final SliderValue hitRange = new SliderValue("Hit Range", 6, 0, 8, 1);
	private final SliderValue delay = new SliderValue("Delay", 400, 0, 5000, 50);
	private final BooleanValue onlyWhenNeed = new BooleanValue("Only When Out of Reach", false);
	private final SliderValue range = new SliderValue("Range", 6, 0, 8, 1);
	private final BooleanValue timer = new BooleanValue("Keep Alive", true);
	private final BooleanValue velocity = new BooleanValue("Velocity", true);
	private final BooleanValue position = new BooleanValue("Position", false);

	public BackTrack() {
		super("BackTrack", ModuleCategory.Exploit);
		this.registerSetting(hitRange, delay, onlyWhenNeed, range, timer, velocity, position);
	}

	@Override
	public void onEnable() {

	}

	@Override
	public void onDisable() {

	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (mc.getNetHandler().getNetworkManager().getNetHandler() != null
				&& mc.getNetHandler().getNetworkManager().getNetHandler() instanceof OldServerPinger)
			return;
		if (PlayerUtil.inGame())
			if (e.getType() == PacketType.Receive) {
				synchronized (this) {
					if (e.getPacket() instanceof S14PacketEntity) {
						final Entity entity = ((S14PacketEntity) e.getPacket()).getEntity(mc.theWorld);
						if (entity instanceof EntityLivingBase) {
							Haru.instance.realPosX += ((S14PacketEntity) e.getPacket()).func_149062_c();
							Haru.instance.realPosY += ((S14PacketEntity) e.getPacket()).func_149061_d();
							Haru.instance.realPosZ += ((S14PacketEntity) e.getPacket()).func_149064_e();
						}
					}
					if (e.getPacket() instanceof S18PacketEntityTeleport) {
						final Entity entity = mc.theWorld
								.getEntityByID(((S18PacketEntityTeleport) e.getPacket()).getEntityId());
						if (entity instanceof EntityLivingBase) {
							Haru.instance.realPosX = ((S18PacketEntityTeleport) e.getPacket()).getX();
							Haru.instance.realPosY = ((S18PacketEntityTeleport) e.getPacket()).getY();
							Haru.instance.realPosZ = ((S18PacketEntityTeleport) e.getPacket()).getZ();
						}
					}

				    entity = mc.theWorld.playerEntities.stream()
				            .filter(entityPlayer -> entityPlayer != mc.thePlayer && entityPlayer.isEntityAlive()
				                    && mc.thePlayer.getDistanceToEntity(entityPlayer) < range.getInput())
				            .min(Comparator.comparingDouble(entityPlayer ->
				                    mc.thePlayer.getDistanceToEntity(entityPlayer)))
				            .orElse(null);

					if (entity == null) {
						resetPackets();
						resetPackets(mc.getNetHandler().getNetworkManager().getNetHandler());
						return;
					}
					if (mc.theWorld != null && mc.thePlayer != null) {
						if (lastWorld != mc.theWorld) {
							resetPackets();
							resetPackets(mc.getNetHandler().getNetworkManager().getNetHandler());
							lastWorld = mc.theWorld;
							return;
						}

						addPackets(e.getPacket(), e);
					}
					lastWorld = mc.theWorld;
				}
			} else if (e.getType() == PacketType.Send) {
				if (position.isToggled() && (e.getPacket() instanceof C03PacketPlayer
						|| e.getPacket() instanceof C03PacketPlayer.C04PacketPlayerPosition
						|| e.getPacket() instanceof C03PacketPlayer.C06PacketPlayerPosLook
						|| e.getPacket() instanceof C03PacketPlayer.C05PacketPlayerLook)) {
					pospacket.add(e.getPacket());
					e.setCancelled(true);
				}
			}
	};

	public void onPreTick(PreTickEvent e) {
		if (mc.getNetHandler().getNetworkManager().getNetHandler() != null
				&& mc.getNetHandler().getNetworkManager().getNetHandler() instanceof OldServerPinger)
			return;

		if (entity != null && mc.thePlayer != null && mc.getNetHandler().getNetworkManager().getNetHandler() != null
				&& mc.theWorld != null) {
			double d0 = (double) Haru.instance.realPosX / 32.0D;
			double d1 = (double) Haru.instance.realPosY / 32.0D;
			double d2 = (double) Haru.instance.realPosZ / 32.0D;
			double d3 = (double) entity.serverPosX / 32.0D;
			double d4 = (double) entity.serverPosY / 32.0D;
			double d5 = (double) entity.serverPosZ / 32.0D;
			AxisAlignedBB alignedBB = new AxisAlignedBB(d3 - (double) entity.width, d4, d5 - (double) entity.width,
					d3 + (double) entity.width, d4 + (double) entity.height, d5 + (double) entity.width);
			Vec3 positionEyes = mc.thePlayer.getPositionEyes(mc.timer.renderPartialTicks);
			double currentX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB.minX, alignedBB.maxX);
			double currentY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB.minY, alignedBB.maxY);
			double currentZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB.minZ, alignedBB.maxZ);
			AxisAlignedBB alignedBB2 = new AxisAlignedBB(d0 - (double) entity.width, d1, d2 - (double) entity.width,
					d0 + (double) entity.width, d1 + (double) entity.height, d2 + (double) entity.width);
			double realX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB2.minX, alignedBB2.maxX);
			double realY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB2.minY, alignedBB2.maxY);
			double realZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB2.minZ, alignedBB2.maxZ);
			double distance = hitRange.getInput();
			if (!mc.thePlayer.canEntityBeSeen(entity)) {
				distance = distance > 3 ? 3 : distance;
			}
			double bestX = MathHelper.clamp_double(positionEyes.xCoord, entity.getEntityBoundingBox().minX,
					entity.getEntityBoundingBox().maxX);
			double bestY = MathHelper.clamp_double(positionEyes.yCoord, entity.getEntityBoundingBox().minY,
					entity.getEntityBoundingBox().maxY);
			double bestZ = MathHelper.clamp_double(positionEyes.zCoord, entity.getEntityBoundingBox().minZ,
					entity.getEntityBoundingBox().maxZ);
			boolean b = positionEyes.distanceTo(new Vec3(bestX, bestY, bestZ)) > 2.9
					|| (mc.thePlayer.hurtTime < 8 && mc.thePlayer.hurtTime > 1);
			if (!onlyWhenNeed.isToggled()) {
				b = true;
			}
			if (!(b && positionEyes.distanceTo(new Vec3(realX, realY, realZ)) > positionEyes
					.distanceTo(new Vec3(currentX, currentY, currentZ)) + 0.05)
					|| !(mc.thePlayer.getDistance(d0, d1, d2) < distance)
					|| timeHelper.reached((long) delay.getInput())) {
				resetPackets();
				resetPackets(mc.getNetHandler().getNetworkManager().getNetHandler());
				timeHelper.reset();
			}

		}
	}

	private void resetPackets(INetHandler netHandler) {
		if (packets.size() > 0) {
			synchronized (packets) {
				while (packets.size() != 0) {
					try {
						packets.get(0).processPacket(netHandler);
					} catch (Exception ignored) {
					}
					packets.remove(packets.get(0));
				}
			}
		}
	}

	private void resetPackets() {
	}

	private void addPackets(Packet<INetHandler> packet, PacketEvent eventReadPacket) {
		synchronized (packets) {
			if (blockPacket(packet)) {
				packets.add(packet);
				eventReadPacket.setCancelled(true);
			}
		}
	}

	private boolean blockPacket(Packet<?> packet) {
		if (packet instanceof S03PacketTimeUpdate) {
			return timer.isToggled();
		} else if (packet instanceof S00PacketKeepAlive) {
			return timer.isToggled();
		} else if (packet instanceof S12PacketEntityVelocity || packet instanceof S27PacketExplosion) {
			return velocity.isToggled();
		} else if (packet instanceof S08PacketPlayerPosLook) {
			return position.isToggled();
		} else {
			return packet instanceof S32PacketConfirmTransaction || packet instanceof S14PacketEntity
					|| packet instanceof S19PacketEntityStatus || packet instanceof S19PacketEntityHeadLook
					|| packet instanceof S18PacketEntityTeleport || packet instanceof S0FPacketSpawnMob;
		}
	}
}
