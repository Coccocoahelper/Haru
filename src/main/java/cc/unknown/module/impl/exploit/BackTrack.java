package cc.unknown.module.impl.exploit;

import java.awt.Color;
import java.util.ArrayList;

import org.lwjgl.opengl.GL11;

import cc.unknown.Haru;
import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.packet.PacketEvent;
import cc.unknown.event.impl.player.PreTickEvent;
import cc.unknown.event.impl.render.Render3DEvent;
import cc.unknown.module.Module;
import cc.unknown.module.impl.ModuleCategory;
import cc.unknown.module.impl.combat.AutoClick;
import cc.unknown.module.impl.combat.KillAura;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.client.AdvancedTimer;
import cc.unknown.utils.helpers.MathHelper;
import cc.unknown.utils.player.CombatUtil;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.network.OldServerPinger;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.S00PacketKeepAlive;
import net.minecraft.network.play.server.S03PacketTimeUpdate;
import net.minecraft.network.play.server.S0FPacketSpawnMob;
import net.minecraft.network.play.server.S12PacketEntityVelocity;
import net.minecraft.network.play.server.S14PacketEntity;
import net.minecraft.network.play.server.S18PacketEntityTeleport;
import net.minecraft.network.play.server.S19PacketEntityHeadLook;
import net.minecraft.network.play.server.S19PacketEntityStatus;
import net.minecraft.network.play.server.S27PacketExplosion;
import net.minecraft.network.play.server.S32PacketConfirmTransaction;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;
import net.minecraft.world.World;

@SuppressWarnings({"rawtypes", "unchecked"})
public class BackTrack extends Module {

	private SliderValue maxDelay = new SliderValue("Delay", 150, 25, 1000, 1);
	private SliderValue maxReach = new SliderValue("Reach", 3.4, 2, 6.0, 0.1);
	private BooleanValue legit = new BooleanValue("Legit", false);
	private BooleanValue renderBox = new BooleanValue("Render Box", true);
	private SliderValue color = new SliderValue("Box Color [H/S/B]", 0, 0, 350, 10);
	private BooleanValue s03 = new BooleanValue("Cancel S03", true);
	private BooleanValue s00 = new BooleanValue("Cancel S00", true);
	private BooleanValue s12 = new BooleanValue("Cancel S12", true);

	private final ArrayList<Packet> packets = new ArrayList<>();

	private EntityPlayer entity = null;
	private INetHandler packetListener = null;
	private WorldClient lastWorld;

	AdvancedTimer timerHelper = new AdvancedTimer(0);

	public BackTrack() {
		super("BackTrack", ModuleCategory.Exploit);
		this.registerSetting(maxDelay, maxReach, legit, renderBox, color, s03, s00, s12);
	}

	@EventLink
	public void onPreTick(PreTickEvent e) {
		if (entity == null) {
			return;
		}
		try {
			if (entity != null && mc.thePlayer != null && packetListener != null && mc.theWorld != null) {
				double d0 = (double) Haru.instance.realPosX / 32.0D;
				double d1 = (double) Haru.instance.realPosY / 32.0D;
				double d2 = (double) Haru.instance.realPosZ / 32.0D;
				double d3 = (double) entity.serverPosX / 32.0D;
				double d4 = (double) entity.serverPosY / 32.0D;
				double d5 = (double) entity.serverPosZ / 32.0D;
				AxisAlignedBB alignedBB = new AxisAlignedBB(d3 - (double) entity.width, d4,
						d5 - (double) entity.width, d3 + (double) entity.width,
						d4 + (double) entity.height, d5 + (double) entity.width);
				Vec3 positionEyes = mc.thePlayer.getPositionEyes(mc.timer.renderPartialTicks);
				double currentX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB.minX, alignedBB.maxX);
				double currentY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB.minY, alignedBB.maxY);
				double currentZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB.minZ, alignedBB.maxZ);
				AxisAlignedBB alignedBB2 = new AxisAlignedBB(d0 - (double) entity.width, d1,
						d2 - (double) entity.width, d0 + (double) entity.width,
						d1 + (double) entity.height, d2 + (double) entity.width);
				double realX = MathHelper.clamp_double(positionEyes.xCoord, alignedBB2.minX, alignedBB2.maxX);
				double realY = MathHelper.clamp_double(positionEyes.yCoord, alignedBB2.minY, alignedBB2.maxY);
				double realZ = MathHelper.clamp_double(positionEyes.zCoord, alignedBB2.minZ, alignedBB2.maxZ);
				double distance = maxReach.getInput();
				if (!mc.thePlayer.canEntityBeSeen(entity)) {
					distance = distance > 3 ? 3 : distance;
				}
				double bestX = MathHelper.clamp_double(positionEyes.xCoord, entity.getEntityBoundingBox().minX,
						entity.getEntityBoundingBox().maxX);
				double bestY = MathHelper.clamp_double(positionEyes.yCoord, entity.getEntityBoundingBox().minY,
						entity.getEntityBoundingBox().maxY);
				double bestZ = MathHelper.clamp_double(positionEyes.zCoord, entity.getEntityBoundingBox().minZ,
						entity.getEntityBoundingBox().maxZ);
				boolean b = false;
				if ((positionEyes.distanceTo(new Vec3(bestX, bestY, bestZ)) > 2.9)) {
					b = true;
				}
				if (!legit.isToggled()) {
					b = true;
				}
				if (!(b && positionEyes.distanceTo(new Vec3(realX, realY, realZ)) > positionEyes
						.distanceTo(new Vec3(currentX, currentY, currentZ)) + 0.05)
						|| !(mc.thePlayer.getDistance(d0, d1, d2) < distance)
						|| timerHelper.reached(maxDelay.getInputToLong())) {
					resetPackets(packetListener);
					timerHelper.reset();
				}

			}
		} catch (Exception ex) {
			entity = null;
		}
	}

	@EventLink
	public void onRender3D(Render3DEvent e) {
		if (entity == null) {
			return;
		}
		try {
			if (entity != null && entity != mc.thePlayer && renderBox.isToggled()) {
				final double x = Haru.instance.realPosX / 32.0D - mc.getRenderManager().renderPosX;
				final double y = Haru.instance.realPosY / 32.0D - mc.getRenderManager().renderPosY;
				final double z = Haru.instance.realPosZ / 32.0D - mc.getRenderManager().renderPosZ;
				double widthX = (entity.getEntityBoundingBox().maxX - entity.getEntityBoundingBox().minX) / 2 + 0.05;
				double widthZ = (entity.getEntityBoundingBox().maxZ - entity.getEntityBoundingBox().minZ) / 2 + 0.05;
				double height = (entity.getEntityBoundingBox().maxY - entity.getEntityBoundingBox().minY);

				if (entity instanceof EntityPlayer)
					height *= 1.1;
				pre3D();
				glColor(getColor(Color.getHSBColor((color.getInputToFloat() % 360) / 360.0f, 1.0f, 1.0f)));
				for (int i = 0; i < 2; i++) {
					if (i == 1)
						glColor(getColor(Color.black));
					GL11.glLineWidth(3 - i * 2);
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x - widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y + height, z - widthZ);
					GL11.glVertex3d(x + widthX, y + height, z - widthZ);
					GL11.glVertex3d(x + widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y, z - widthZ);
					GL11.glVertex3d(x - widthX, y, z + widthZ);
					GL11.glEnd();
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x + widthX, y, z + widthZ);
					GL11.glVertex3d(x + widthX, y + height, z + widthZ);
					GL11.glVertex3d(x - widthX, y + height, z + widthZ);
					GL11.glVertex3d(x - widthX, y, z + widthZ);
					GL11.glVertex3d(x + widthX, y, z + widthZ);
					GL11.glVertex3d(x + widthX, y, z - widthZ);
					GL11.glEnd();
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x + widthX, y + height, z + widthZ);
					GL11.glVertex3d(x + widthX, y + height, z - widthZ);
					GL11.glEnd();
					GL11.glBegin(GL11.GL_LINE_STRIP);
					GL11.glVertex3d(x - widthX, y + height, z + widthZ);
					GL11.glVertex3d(x - widthX, y + height, z - widthZ);
					GL11.glEnd();
				}

				post3D();

			}

		} catch (Exception ex) {

		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (e.getNetHandler() != null && e.getNetHandler() instanceof OldServerPinger)
			return;
		if (mc.theWorld != null)
			if (e.isReceive()) {
				packetListener = e.getNetHandler();
				synchronized (BackTrack.class) {
					if (e.getPacket() instanceof S14PacketEntity) {
						S14PacketEntity packetEntity = (S14PacketEntity) e.getPacket();
						if (entity != null && packetEntity.getEntity((World) mc.theWorld).equals(entity)) {
							Haru.instance.realPosX += packetEntity.func_149062_c();
							Haru.instance.realPosY += packetEntity.func_149061_d();
							Haru.instance.realPosZ += packetEntity.func_149064_e();
						}
					}
					if (e.getPacket() instanceof S18PacketEntityTeleport) {
						S18PacketEntityTeleport teleportPacket = (S18PacketEntityTeleport) e.getPacket();
						if (entity != null && teleportPacket.getEntityId() == entity.getEntityId()) {
							Haru.instance.realPosX = teleportPacket.getX();
							Haru.instance.realPosY = teleportPacket.getY();
							Haru.instance.realPosZ = teleportPacket.getZ();
						}
					}

					entity = null;
					if (Haru.instance.getModuleManager().getModule(AutoClick.class).isEnabled()
							|| Haru.instance.getModuleManager().getModule(KillAura.class).isEnabled()) {
						if (CombatUtil.instance.getTarget() != null) {
							entity = CombatUtil.instance.getTarget();
						}
					}

					if (entity == null) {
						resetPackets(e.getNetHandler());
						return;
					}
					if (mc.theWorld != null && mc.thePlayer != null) {
						if (lastWorld != mc.theWorld) {
							resetPackets(e.getNetHandler());
							lastWorld = mc.theWorld;
							return;
						}
						addPackets(e.getPacket(), e);
					}
					lastWorld = mc.theWorld;
				}
			}
	}

	private void resetPackets(INetHandler netHandler) {
		if (packets.size() > 0) {
			synchronized (packets) {
				while (packets.size() != 0) {
					try {
						packets.get(0).processPacket(netHandler);
					} catch (Exception ignored) {
					}
					packets.remove(packets.get(0));
				}

			}
		}
	}

	private void addPackets(Packet packet, PacketEvent eventReadPacket) {
		synchronized (packets) {
			if (blockPacket(packet)) {
				packets.add(packet);
				eventReadPacket.setCancelled(true);
			}
		}
	}

	private boolean blockPacket(Packet packet) {
		if (packet instanceof S03PacketTimeUpdate) {
			return s03.isToggled();
		} else if (packet instanceof S00PacketKeepAlive) {
			return s00.isToggled();
		} else if (packet instanceof S12PacketEntityVelocity || packet instanceof S27PacketExplosion) {
			return s12.isToggled();
		} else {
			return packet instanceof S32PacketConfirmTransaction || packet instanceof S14PacketEntity
					|| packet instanceof S19PacketEntityStatus || packet instanceof S19PacketEntityHeadLook
					|| packet instanceof S18PacketEntityTeleport || packet instanceof S0FPacketSpawnMob;
		}
	}

	private void glColor(int hex) {
		float alpha = (hex >> 24 & 0xFF) / 255.0F;
		float red = (hex >> 16 & 0xFF) / 255.0F;
		float green = (hex >> 8 & 0xFF) / 255.0F;
		float blue = (hex & 0xFF) / 255.0F;
		GL11.glColor4f(red, green, blue, alpha);
	}

	private int getColor(Color color) {
		return getColor(color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha());
	}

	private int getColor(int red, int green, int blue, int alpha) {
		int color = 0;
		color |= alpha << 24;
		color |= red << 16;
		color |= green << 8;
		color |= blue;
		return color;
	}

	private void pre3D() {
		GL11.glPushMatrix();
		GL11.glEnable(GL11.GL_BLEND);
		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
		GL11.glShadeModel(GL11.GL_SMOOTH);
		GL11.glDisable(GL11.GL_TEXTURE_2D);
		GL11.glEnable(GL11.GL_LINE_SMOOTH);
		GL11.glDisable(GL11.GL_DEPTH_TEST);
		GL11.glDisable(GL11.GL_LIGHTING);
		GL11.glDepthMask(false);
		GL11.glHint(GL11.GL_LINE_SMOOTH_HINT, GL11.GL_NICEST);
	}

	private void post3D() {
		GL11.glDepthMask(true);
		GL11.glEnable(GL11.GL_DEPTH_TEST);
		GL11.glDisable(GL11.GL_LINE_SMOOTH);
		GL11.glEnable(GL11.GL_TEXTURE_2D);
		GL11.glDisable(GL11.GL_BLEND);
		GL11.glPopMatrix();
		GL11.glColor4f(1, 1, 1, 1);
	}
}
